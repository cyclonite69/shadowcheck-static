<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowCheck - Surveillance</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="stylesheet" href="/assets/styles/unified.css">
</head>
<body data-page="surveillance">
    <div class="app-container">
        <header class="app-header">
            <div class="header-left">
                <div class="logo">SC</div>
                <span class="font-semibold">ShadowCheck</span>
            </div>
            <nav class="nav-links">
                <a href="/" class="nav-link">Dashboard</a>
                <a href="/networks.html" class="nav-link">Networks</a>
                <a href="/geospatial.html" class="nav-link">Geospatial</a>
                <a href="/surveillance.html" class="nav-link active">Surveillance</a>
                <a href="/analytics.html" class="nav-link">Analytics</a>
                <a href="/admin.html" class="nav-link">Admin</a>
            </nav>
            <div class="header-right">
                <button class="btn btn-sm" onclick="window.baseComponents?.showCardLibrary()">‚ûï Add Card</button>
                <button class="btn btn-sm" onclick="window.baseComponents?.toggleSnap(this)">üî≤ Snap: ON</button>
                <button class="btn btn-sm" onclick="window.baseComponents?.resetLayout()">‚Ü∫ Reset</button>
                <button class="btn btn-sm" onclick="location.reload()">üîÑ Refresh</button>
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </header>

        <main class="app-main">
            <!-- METRICS AND CHARTS -->
            <div class="metrics-and-charts">
                <!-- THREAT METRICS -->
                <div class="panel metrics-grid">
                    <div class="metric-card critical">
                        <div class="metric-label">Critical (80+)</div>
                        <div class="metric-value" id="critical-count">0</div>
                    </div>
                    <div class="metric-card high">
                        <div class="metric-label">High (70-79)</div>
                        <div class="metric-value" id="high-count">0</div>
                    </div>
                    <div class="metric-card medium">
                        <div class="metric-label">Medium (50-69)</div>
                        <div class="metric-value" id="medium-count">0</div>
                    </div>
                    <div class="metric-card low">
                        <div class="metric-label">Low (30-49)</div>
                        <div class="metric-value" id="low-count">0</div>
                    </div>
                </div>

                <!-- THREAT DISTRIBUTION CHART -->
                <div class="panel">
                    <div class="panel-header">üìä Threat Score Distribution</div>
                    <div class="panel-content">
                        <div class="chart-container">
                            <canvas id="threatChart"></canvas>
                        </div>
                    </div>
                </div>

                <!-- TEMPORAL ACTIVITY CHART -->
                <div class="panel">
                    <div class="panel-header">‚è∞ Temporal Activity Patterns</div>
                    <div class="panel-content">
                        <div class="chart-container">
                            <canvas id="temporalChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>

            <!-- THREAT LISTS -->
            <div class="threat-lists-container">
            
            <!-- Filter Controls -->
            <div class="panel">
                <div class="panel-header">üéõÔ∏è Threat Filters</div>
                <div class="panel-content" style="padding: 12px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 12px;">
                        <div>
                            <label style="display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Search BSSID/SSID</label>
                            <input type="text" id="threat-search" placeholder="Search..." style="width: 100%; padding: 6px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Min Observations</label>
                            <input type="number" id="filter-min-obs" value="5" min="1" max="1000" style="width: 100%; padding: 6px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Min Unique Days</label>
                            <input type="number" id="filter-min-days" value="3" min="1" max="365" style="width: 100%; padding: 6px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Min Locations</label>
                            <input type="number" id="filter-min-locs" value="5" min="1" max="100" style="width: 100%; padding: 6px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Min Range (km)</label>
                            <input type="number" id="filter-min-range" value="0.5" min="0" max="100" step="0.1" style="width: 100%; padding: 6px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                        </div>
                        <div>
                            <label style="display: block; font-size: 11px; color: #94a3b8; margin-bottom: 4px;">Min Threat Score</label>
                            <input type="number" id="filter-min-score" value="40" min="0" max="200" style="width: 100%; padding: 6px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                        </div>
                    </div>
                    <button id="apply-filters-btn" style="margin-top: 12px; width: 100%; padding: 8px; background: rgba(59, 130, 246, 0.2); border: 1px solid rgba(59, 130, 246, 0.4); color: #60a5fa; border-radius: 6px; font-size: 12px; font-weight: 600; cursor: pointer;">
                        Apply Filters
                    </button>
                </div>
            </div>
            
            <!-- Active Threats -->
            <div class="panel">
                <div class="panel-header" style="display: flex; justify-content: space-between; align-items: center;">
                    <div style="display: flex; align-items: center; gap: 8px;">
                        üîç Active Threats - Click to Investigate
                        <span id="threat-list-count" style="background: rgba(239, 68, 68, 0.2); color: #fca5a5; padding: 2px 8px; border-radius: 4px; font-size: 11px;">0</span>
                    </div>
                    <select id="threat-severity-filter" style="background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; padding: 6px 10px; border-radius: 6px; font-size: 11px;">
                        <option value="all">All Severity Levels</option>
                        <option value="critical">Critical (80+)</option>
                        <option value="high">High (70-79)</option>
                        <option value="medium">Medium (50-69)</option>
                        <option value="low">Low (30-49)</option>
                    </select>
                </div>
                <div class="panel-content" style="overflow-y: auto; max-height: 600px;">
                    <div id="threat-investigation-list" style="display: flex; flex-direction: column; gap: 8px;">
                        <div class="loading">Loading threats...</div>
                    </div>
                </div>
            </div>

            <!-- Confirmed Threats -->
            <div class="panel">
                <div class="panel-header" style="display: flex; align-items: center; gap: 8px;">
                    <span>‚ö†Ô∏è Confirmed Threats</span>
                    <span id="confirmed-threats-count" style="background: rgba(239, 68, 68, 0.2); color: #fca5a5; padding: 2px 8px; border-radius: 4px; font-size: 11px;">0</span>
                </div>
                <div class="panel-content" style="overflow-y: auto;">
                    <div id="confirmed-threats-list" style="display: flex; flex-direction: column; gap: 6px;">
                        <div class="loading">Loading...</div>
                    </div>
                </div>
            </div>

            <!-- Tagged Safe -->
            <div class="panel">
                <div class="panel-header" style="display: flex; align-items: center; gap: 8px;">
                    <span>‚úì Tagged Safe</span>
                    <span id="tagged-safe-count" style="background: rgba(34, 197, 94, 0.2); color: #4ade80; padding: 2px 8px; border-radius: 4px; font-size: 11px;">0</span>
                </div>
                <div class="panel-content" style="overflow-y: auto;">
                    <div id="tagged-safe-list" style="display: flex; flex-direction: column; gap: 6px;">
                        <div class="loading">Loading...</div>
                    </div>
                </div>
            </div>
            </div>
        </div>
    </div>

    <script>
        // HTML escaping utility to prevent XSS
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Use dynamic API base URL based on current window location
        const API_BASE = Object.freeze(`${window.location.protocol}//${window.location.hostname}:3001/api`);
        let threatChart = null;
        let temporalChart = null;
        let minThreatSeverity = 'all'; // Default: show all

        // Pagination state for infinite scroll
        const pagination = {
            activeThreats: { page: 1, limit: 50, hasMore: true, loading: false, totalCount: 0 },
            confirmedThreats: { page: 1, limit: 50, hasMore: true, loading: false, totalCount: 0 },
            taggedSafe: { page: 1, limit: 50, hasMore: true, loading: false, totalCount: 0 }
        };

        // Highlight active nav
        function highlightActiveNav() {
            const currentPath = window.location.pathname;
            document.querySelectorAll('a.nav-link').forEach(link => {
                link.classList.remove('active');
                const href = link.getAttribute('href');

                if ((currentPath === '/' || currentPath === '/index.html') && (href === '/' || href === '/index.html')) {
                    link.classList.add('active');
                } else if (href !== '/' && currentPath.includes(href.replace('/', ''))) {
                    link.classList.add('active');
                }
            });
        }

        // Load metrics
        async function loadMetrics() {
            try {
                console.log('üìä Loading threat metrics...');
                // Fetch ALL threats to get accurate counts
                const response = await fetch(`${API_BASE}/threats/quick?page=1&limit=10000`);

                if (!response.ok) {
                    console.error('‚úó Metrics API failed:', response.status);
                    return;
                }

                const data = await response.json();
                const threats = data.threats || [];

                console.log(`‚úì Loaded ${threats.length} threats from API`);

                // Count threats by severity
                let criticalCount = 0;
                let highCount = 0;
                let mediumCount = 0;
                let lowCount = 0;

                threats.forEach(threat => {
                    const score = threat.threatScore;
                    if (score >= 80) {
                        criticalCount++;
                    } else if (score >= 70) {
                        highCount++;
                    } else if (score >= 50) {
                        mediumCount++;
                    } else if (score >= 30) {
                        lowCount++;
                    }
                });

                document.getElementById('critical-count').textContent = criticalCount;
                document.getElementById('high-count').textContent = highCount;
                document.getElementById('medium-count').textContent = mediumCount;
                document.getElementById('low-count').textContent = lowCount;

                console.log('‚úì Metrics loaded:', {
                    critical: criticalCount,
                    high: highCount,
                    medium: mediumCount,
                    low: lowCount,
                    total: threats.length
                });
            } catch (err) {
                console.error('‚úó Error loading metrics:', err);
            }
        }

        // Load threat distribution chart
        async function loadThreatChart() {
            try {
                console.log(`üìä Loading threat distribution (minSeverity: ${minThreatSeverity})...`);
                const url = minThreatSeverity > 0
                    ? `${API_BASE}/threats/quick?page=1&limit=100&minSeverity=${minThreatSeverity}`
                    : `${API_BASE}/threats/quick?page=1&limit=100`;
                const response = await fetch(url);

                if (!response.ok) {
                    console.error('‚úó Threats API failed:', response.status);
                    return;
                }

                const data = await response.json();

                if (!data || !data.threats || !Array.isArray(data.threats)) {
                    console.warn('‚ö†Ô∏è No threat data available');
                    return;
                }

                const scores = data.threats.map(t => t.threatScore);
                const bins = { '30-40': 0, '40-50': 0, '50-60': 0, '60-70': 0, '70-80': 0, '80-90': 0, '90-100': 0 };

                scores.forEach(score => {
                    if (score < 40) bins['30-40']++;
                    else if (score < 50) bins['40-50']++;
                    else if (score < 60) bins['50-60']++;
                    else if (score < 70) bins['60-70']++;
                    else if (score < 80) bins['70-80']++;
                    else if (score < 90) bins['80-90']++;
                    else bins['90-100']++;
                });

                const ctx = document.getElementById('threatChart').getContext('2d');
                if (threatChart) threatChart.destroy();

                threatChart = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: Object.keys(bins),
                        datasets: [{
                            label: 'Threat Count',
                            data: Object.values(bins),
                            backgroundColor: 'rgba(239, 68, 68, 0.5)',
                            borderColor: 'rgba(239, 68, 68, 1)',
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148, 163, 184, 0.1)' } },
                            x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148, 163, 184, 0.1)' } }
                        }
                    }
                });

                console.log(`‚úì Threat distribution chart rendered (${data.threats.length} threats)`);
            } catch (err) {
                console.error('‚úó Error loading threat chart:', err);
            }
        }

        // Load temporal activity chart
        async function loadTemporalChart() {
            try {
                console.log('‚è∞ Loading temporal activity...');
                const response = await fetch(`${API_BASE}/temporal-activity`);

                if (!response.ok) {
                    console.error('‚úó Temporal activity API failed:', response.status);
                    return;
                }

                const data = await response.json();

                if (!data || !data.data || !Array.isArray(data.data)) {
                    console.warn('‚ö†Ô∏è No temporal activity data available');
                    return;
                }

                const ctx = document.getElementById('temporalChart').getContext('2d');
                if (temporalChart) temporalChart.destroy();

                temporalChart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: data.data.map(d => `${d.hour}:00`),
                        datasets: [{
                            label: 'Network Activity',
                            data: data.data.map(d => d.count),
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            borderColor: 'rgba(59, 130, 246, 1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            y: { beginAtZero: true, ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148, 163, 184, 0.1)' } },
                            x: { ticks: { color: '#94a3b8' }, grid: { color: 'rgba(148, 163, 184, 0.1)' } }
                        }
                    }
                });

                console.log('‚úì Temporal activity chart rendered');
            } catch (err) {
                console.error('‚úó Error loading temporal chart:', err);
            }
        }

        // Get severity class based on threat score
        function getSeverityClass(score) {
            if (score >= 80) return 'severity-critical';
            if (score >= 70) return 'severity-high';
            if (score >= 50) return 'severity-medium';
            return 'severity-low';
        }

        // Get radio type icon
        function getRadioIcon(type) {
            const icons = {
                'wifi': 'üì°',
                'bluetooth': 'üîµ',
                'ble': 'üî∑',
                'lte': 'üì±',
                'gsm': 'üìû',
                'nr': '5Ô∏è‚É£'
            };
            return icons[type?.toLowerCase()] || 'üì°';
        }

        // Get severity label based on threat score
        function getSeverityLabel(score) {
            if (score >= 80) return 'Critical';
            if (score >= 70) return 'High';
            if (score >= 50) return 'Medium';
            return 'Low';
        }

        // Tag a network as safe or threat
        async function tagNetwork(bssid, tagType, confidence = 50) {
            try {
                const API_KEY = localStorage.getItem('shadowcheck_api_key') || 'your-secure-random-key-here';
                
                const response = await fetch(`${API_BASE}/tag-network`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-API-Key': API_KEY
                    },
                    body: JSON.stringify({
                        bssid: bssid,
                        tag_type: tagType,
                        confidence: confidence,
                        notes: `User tagged as ${tagType}`
                    })
                });

                if (!response.ok) {
                    console.error('‚úó Tag network failed:', response.status);
                    return false;
                }

                const result = await response.json();
                console.log(`‚úì Network tagged: ${bssid} as ${tagType}`);

                // Reload all lists to reflect changes
                await loadThreatList();
                await loadConfirmedThreats();
                await loadTaggedSafe();
                return true;
            } catch (err) {
                console.error('‚úó Error tagging network:', err);
                return false;
            }
        }

        // Load confirmed threats list (tagged as THREAT)
        async function loadConfirmedThreats(append = false) {
            try {
                if (pagination.confirmedThreats.loading || (!append && pagination.confirmedThreats.page !== 1)) {
                    if (!append) {
                        // Reset pagination for fresh load
                        pagination.confirmedThreats.page = 1;
                        pagination.confirmedThreats.hasMore = true;
                    }
                    if (pagination.confirmedThreats.loading) return;
                }

                pagination.confirmedThreats.loading = true;

                console.log(`üö® Loading confirmed threats (page ${pagination.confirmedThreats.page})...`);
                const response = await fetch(`${API_BASE}/networks/tagged?tag_type=THREAT&page=${pagination.confirmedThreats.page}&limit=${pagination.confirmedThreats.limit}`);

                if (!response.ok) {
                    console.error('‚úó Confirmed threats API failed:', response.status);
                    pagination.confirmedThreats.loading = false;
                    return;
                }

                const data = await response.json();
                const listEl = document.getElementById('confirmed-threats-list');
                const countEl = document.getElementById('confirmed-threats-count');

                if (!data.ok || !data.networks || data.networks.length === 0) {
                    if (!append) {
                        listEl.innerHTML = '<div class="loading">No confirmed threats</div>';
                        countEl.textContent = '0';
                    }
                    pagination.confirmedThreats.hasMore = false;
                    pagination.confirmedThreats.loading = false;
                    return;
                }

                pagination.confirmedThreats.totalCount = data.totalCount || data.networks.length;
                pagination.confirmedThreats.hasMore = (pagination.confirmedThreats.page * pagination.confirmedThreats.limit) < pagination.confirmedThreats.totalCount;

                countEl.textContent = pagination.confirmedThreats.totalCount;

                if (!append) {
                    listEl.innerHTML = '';
                }

                data.networks.forEach(network => {
                    const item = document.createElement('div');
                    item.style.cssText = `
                        background: rgba(239, 68, 68, 0.1);
                        border: 1px solid rgba(239, 68, 68, 0.3);
                        border-left: 3px solid #dc2626;
                        border-radius: 6px;
                        padding: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-size: 11px;
                    `;

                    const timespanDays = network.observation_timespan_ms ? Math.round(parseInt(network.observation_timespan_ms) / (1000 * 60 * 60 * 24)) : 0;

                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 8px;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="display: flex; align-items: center; gap: 6px; font-weight: 600; color: #fca5a5; margin-bottom: 4px;">
                                    ${getRadioIcon(network.type)}
                                    <span>${escapeHtml(network.ssid) || 'Hidden Network'}</span>
                                </div>
                                <div style="font-size: 10px; color: #94a3b8;">
                                    ${escapeHtml(network.bssid)}${network.observation_count ? ` ‚Ä¢ ${network.observation_count} obs` : ''}${network.first_seen && network.last_seen ? ` ‚Ä¢ ${new Date(parseInt(network.first_seen)).toLocaleDateString()} - ${new Date(parseInt(network.last_seen)).toLocaleDateString()} (${timespanDays}d)` : ''}
                                </div>
                            </div>
                            <button class="untag-btn" style="
                                background: rgba(148, 163, 184, 0.2);
                                border: 1px solid rgba(148, 163, 184, 0.3);
                                color: #cbd5e1;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Remove tag">
                                ‚úï Untag
                            </button>
                        </div>
                    `;

                    const untagBtn = item.querySelector('.untag-btn');
                    untagBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (confirm(`Remove THREAT tag from ${network.ssid || network.bssid}?`)) {
                            await untagNetwork(network.bssid);
                        }
                    });

                    item.addEventListener('click', () => {
                        window.location.href = `/geospatial.html?bssid=${encodeURIComponent(network.bssid)}&ssid=${encodeURIComponent(network.ssid || '')}`;
                    });

                    listEl.appendChild(item);
                });

                console.log(`‚úì Loaded ${data.networks.length} confirmed threats (page ${pagination.confirmedThreats.page})`);
                pagination.confirmedThreats.loading = false;
            } catch (err) {
                console.error('‚úó Error loading confirmed threats:', err);
                pagination.confirmedThreats.loading = false;
            }
        }

        // Load tagged safe list (tagged as FALSE_POSITIVE)
        async function loadTaggedSafe(append = false) {
            try {
                if (pagination.taggedSafe.loading || (!append && pagination.taggedSafe.page !== 1)) {
                    if (!append) {
                        // Reset pagination for fresh load
                        pagination.taggedSafe.page = 1;
                        pagination.taggedSafe.hasMore = true;
                    }
                    if (pagination.taggedSafe.loading) return;
                }

                pagination.taggedSafe.loading = true;

                console.log(`‚úÖ Loading tagged safe networks (page ${pagination.taggedSafe.page})...`);
                const response = await fetch(`${API_BASE}/networks/tagged?tag_type=FALSE_POSITIVE&page=${pagination.taggedSafe.page}&limit=${pagination.taggedSafe.limit}`);

                if (!response.ok) {
                    console.error('‚úó Tagged safe API failed:', response.status);
                    pagination.taggedSafe.loading = false;
                    return;
                }

                const data = await response.json();
                const listEl = document.getElementById('tagged-safe-list');
                const countEl = document.getElementById('tagged-safe-count');

                if (!data.ok || !data.networks || data.networks.length === 0) {
                    if (!append) {
                        listEl.innerHTML = '<div class="loading">No safe networks</div>';
                        countEl.textContent = '0';
                    }
                    pagination.taggedSafe.hasMore = false;
                    pagination.taggedSafe.loading = false;
                    return;
                }

                pagination.taggedSafe.totalCount = data.totalCount || data.networks.length;
                pagination.taggedSafe.hasMore = (pagination.taggedSafe.page * pagination.taggedSafe.limit) < pagination.taggedSafe.totalCount;

                countEl.textContent = pagination.taggedSafe.totalCount;

                if (!append) {
                    listEl.innerHTML = '';
                }

                data.networks.forEach(network => {
                    const item = document.createElement('div');
                    item.style.cssText = `
                        background: rgba(34, 197, 94, 0.1);
                        border: 1px solid rgba(34, 197, 94, 0.3);
                        border-left: 3px solid #16a34a;
                        border-radius: 6px;
                        padding: 8px;
                        cursor: pointer;
                        transition: all 0.2s;
                        font-size: 11px;
                        opacity: 0.7;
                    `;

                    const timespanDays = network.observation_timespan_ms ? Math.round(parseInt(network.observation_timespan_ms) / (1000 * 60 * 60 * 24)) : 0;

                    item.innerHTML = `
                        <div style="display: flex; justify-content: space-between; align-items: start; gap: 8px;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="display: flex; align-items: center; gap: 6px; font-weight: 600; color: #4ade80; margin-bottom: 4px;">
                                    ${getRadioIcon(network.type)}
                                    <span>${escapeHtml(network.ssid) || 'Hidden Network'}</span>
                                </div>
                                <div style="font-size: 10px; color: #94a3b8;">
                                    ${escapeHtml(network.bssid)}${network.observation_count ? ` ‚Ä¢ ${network.observation_count} obs` : ''}${network.first_seen && network.last_seen ? ` ‚Ä¢ ${new Date(parseInt(network.first_seen)).toLocaleDateString()} - ${new Date(parseInt(network.last_seen)).toLocaleDateString()} (${timespanDays}d)` : ''}
                                </div>
                            </div>
                            <button class="untag-btn" style="
                                background: rgba(148, 163, 184, 0.2);
                                border: 1px solid rgba(148, 163, 184, 0.3);
                                color: #cbd5e1;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Remove tag">
                                ‚úï Untag
                            </button>
                        </div>
                    `;

                    const untagBtn = item.querySelector('.untag-btn');
                    untagBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        if (confirm(`Remove SAFE tag from ${network.ssid || network.bssid}?`)) {
                            await untagNetwork(network.bssid);
                        }
                    });

                    item.addEventListener('click', () => {
                        window.location.href = `/geospatial.html?bssid=${encodeURIComponent(network.bssid)}&ssid=${encodeURIComponent(network.ssid || '')}`;
                    });

                    listEl.appendChild(item);
                });

                console.log(`‚úì Loaded ${data.networks.length} safe networks (page ${pagination.taggedSafe.page})`);
                pagination.taggedSafe.loading = false;
            } catch (err) {
                console.error('‚úó Error loading safe networks:', err);
                pagination.taggedSafe.loading = false;
            }
        }

        // Untag a network (remove all tags)
        async function untagNetwork(bssid) {
            try {
                const response = await fetch(`${API_BASE}/tag-network/${bssid}`, {
                    method: 'DELETE'
                });

                if (!response.ok) {
                    console.error('‚úó Untag network failed:', response.status);
                    return false;
                }

                const result = await response.json();
                console.log(`‚úì Network untagged: ${bssid}`);

                // Reload all lists to reflect changes
                await loadThreatList();
                await loadConfirmedThreats();
                await loadTaggedSafe();
                return true;
            } catch (err) {
                console.error('‚úó Error untagging network:', err);
                return false;
            }
        }

        // Load threat list for investigation
        async function loadThreatList(append = false) {
            try {
                if (pagination.activeThreats.loading || (!append && pagination.activeThreats.page !== 1)) {
                    if (!append) {
                        // Reset pagination for fresh load
                        pagination.activeThreats.page = 1;
                        pagination.activeThreats.hasMore = true;
                    }
                    if (pagination.activeThreats.loading) return;
                }

                pagination.activeThreats.loading = true;

                // Build URL with filter parameters
                const params = new URLSearchParams({
                    page: pagination.activeThreats.page,
                    limit: pagination.activeThreats.limit
                });
                
                // Add configurable filters if set
                const minObs = document.getElementById('filter-min-obs')?.value;
                const minDays = document.getElementById('filter-min-days')?.value;
                const minLocs = document.getElementById('filter-min-locs')?.value;
                const minRange = document.getElementById('filter-min-range')?.value;
                const minScore = document.getElementById('filter-min-score')?.value;
                
                if (minObs) params.append('minObs', minObs);
                if (minDays) params.append('minDays', minDays);
                if (minLocs) params.append('minLocs', minLocs);
                if (minRange) params.append('minRange', minRange);
                if (minScore) params.append('minScore', minScore);

                console.log(`üîç Loading threat investigation list (page ${pagination.activeThreats.page}, filters: ${params.toString()})...`);
                const url = `${API_BASE}/threats/quick?${params.toString()}`;
                const response = await fetch(url);

                if (!response.ok) {
                    console.error('‚úó Threats API failed:', response.status);
                    pagination.activeThreats.loading = false;
                    return;
                }

                const data = await response.json();

                const listEl = document.getElementById('threat-investigation-list');
                const countEl = document.getElementById('threat-list-count');

                if (!data || !data.threats || !Array.isArray(data.threats) || data.threats.length === 0) {
                    if (!append) {
                        listEl.innerHTML = '<div class="loading">No threats detected</div>';
                        countEl.textContent = '0';
                    }
                    pagination.activeThreats.hasMore = false;
                    pagination.activeThreats.loading = false;
                    return;
                }

                // Update pagination info
                pagination.activeThreats.totalCount = data.total || data.threats.length;
                pagination.activeThreats.hasMore = (pagination.activeThreats.page * pagination.activeThreats.limit) < pagination.activeThreats.totalCount;

                // Filter threats by selected severity level
                let filteredThreats = data.threats;
                
                // Apply search filter
                const searchText = document.getElementById('threat-search')?.value?.toLowerCase();
                if (searchText) {
                    filteredThreats = filteredThreats.filter(threat => 
                        threat.bssid?.toLowerCase().includes(searchText) ||
                        threat.ssid?.toLowerCase().includes(searchText)
                    );
                }
                
                // Apply severity filter
                if (minThreatSeverity !== 'all') {
                    filteredThreats = filteredThreats.filter(threat => {
                        const severityClass = getSeverityClass(threat.threatScore);
                        return severityClass === `severity-${minThreatSeverity}`;
                    });
                }

                if (filteredThreats.length === 0 && !append) {
                    listEl.innerHTML = '<div class="loading">No threats at this severity level</div>';
                    countEl.textContent = '0';
                    pagination.activeThreats.loading = false;
                    return;
                }

                // Only update count on first load
                if (!append) {
                    countEl.textContent = pagination.activeThreats.totalCount;
                    listEl.innerHTML = '';
                }

                filteredThreats.forEach(threat => {
                    const item = document.createElement('div');
                    const severityClass = getSeverityClass(threat.threatScore);
                    const severityLabel = getSeverityLabel(threat.threatScore);
                    const timespanDays = Math.round((parseInt(threat.lastSeen) - parseInt(threat.firstSeen)) / (1000 * 60 * 60 * 24));

                    item.className = `threat-row ${severityClass}`;

                    item.innerHTML = `
                        <div style="display: flex; gap: 12px; align-items: start;">
                            <div style="flex: 1; min-width: 0;">
                                <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap; margin-bottom: 6px;">
                                    ${getRadioIcon(threat.radioType)}
                                    <div style="font-weight: 600; font-size: 13px; color: #f1f5f9;">
                                        ${escapeHtml(threat.ssid) || 'Hidden Network'}
                                    </div>
                                    <span class="threat-score ${severityClass}">${escapeHtml(severityLabel)}: ${threat.threatScore}</span>
                                </div>
                                <div style="font-size: 11px; color: #94a3b8; line-height: 1.5;">
                                    <div><strong>BSSID:</strong> ${escapeHtml(threat.bssid)}</div>
                                    <div style="display: flex; gap: 16px; flex-wrap: wrap; margin-top: 4px;">
                                        <span><strong>Observations:</strong> ${threat.totalObservations}</span>
                                        <span><strong>Days Active:</strong> ${timespanDays}d</span>
                                        <span><strong>Unique Days:</strong> ${threat.uniqueDays}</span>
                                        <span><strong>Locations:</strong> ${threat.uniqueLocations}</span>
                                        <span><strong>Range:</strong> ${threat.distanceRangeKm} km</span>
                                    </div>
                                    <div style="margin-top: 4px;">
                                        <strong>First:</strong> ${new Date(parseInt(threat.firstSeen)).toLocaleString()} ‚Ä¢ 
                                        <strong>Last:</strong> ${new Date(parseInt(threat.lastSeen)).toLocaleString()}
                                    </div>
                                </div>
                            </div>
                            <div style="display: flex; flex-direction: column; gap: 6px; flex-shrink: 0;">
                                <button class="tag-safe-btn" style="
                                    background: rgba(34, 197, 94, 0.2);
                                    border: 1px solid rgba(34, 197, 94, 0.4);
                                    color: #4ade80;
                                    padding: 6px 12px;
                                    border-radius: 4px;
                                    font-size: 11px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    white-space: nowrap;
                                " title="Mark as safe (false positive)">
                                    ‚úì Safe
                                </button>
                                <button class="tag-threat-btn" style="
                                    background: rgba(239, 68, 68, 0.2);
                                    border: 1px solid rgba(239, 68, 68, 0.4);
                                    color: #f87171;
                                    padding: 6px 12px;
                                    border-radius: 4px;
                                    font-size: 11px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    white-space: nowrap;
                                " title="Confirm as threat">
                                    ‚ö† Threat
                                </button>
                                <button class="investigate-btn" style="
                                    background: rgba(59, 130, 246, 0.2);
                                    border: 1px solid rgba(59, 130, 246, 0.4);
                                    color: #60a5fa;
                                    padding: 6px 12px;
                                    border-radius: 4px;
                                    font-size: 11px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    white-space: nowrap;
                                " title="Investigate on map">
                                    üîç Map
                                </button>
                                <button class="wigle-btn" style="
                                    background: rgba(168, 85, 247, 0.2);
                                    border: 1px solid rgba(168, 85, 247, 0.4);
                                    color: #c084fc;
                                    padding: 6px 12px;
                                    border-radius: 4px;
                                    font-size: 11px;
                                    font-weight: 600;
                                    cursor: pointer;
                                    white-space: nowrap;
                                " title="Lookup in WiGLE database">
                                    üåê WiGLE
                                </button>
                            </div>
                        </div>
                    `;

                    // Add event listeners for tagging buttons
                    const safeBtn = item.querySelector('.tag-safe-btn');
                    const threatBtn = item.querySelector('.tag-threat-btn');
                    const investigateBtn = item.querySelector('.investigate-btn');
                    const wigleBtn = item.querySelector('.wigle-btn');

                    // Check if already tagged and update button state
                    if (threat.isTagged) {
                        if (threat.userTag === 'FALSE_POSITIVE') {
                            safeBtn.style.background = 'rgba(34, 197, 94, 0.5)';
                            safeBtn.style.borderColor = '#22c55e';
                            safeBtn.disabled = true;
                            safeBtn.style.opacity = '1';
                            safeBtn.style.cursor = 'not-allowed';
                        } else if (threat.userTag === 'THREAT') {
                            threatBtn.style.background = 'rgba(239, 68, 68, 0.5)';
                            threatBtn.style.borderColor = '#ef4444';
                            threatBtn.disabled = true;
                            threatBtn.style.opacity = '1';
                            threatBtn.style.cursor = 'not-allowed';
                        }
                    }

                    safeBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const success = await tagNetwork(threat.bssid, 'FALSE_POSITIVE', 90);
                        if (success) {
                            safeBtn.style.background = 'rgba(34, 197, 94, 0.5)';
                            safeBtn.style.borderColor = '#22c55e';
                            safeBtn.disabled = true;
                            safeBtn.style.opacity = '1';
                            safeBtn.style.cursor = 'not-allowed';
                        }
                    });

                    threatBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        const success = await tagNetwork(threat.bssid, 'THREAT', 90);
                        if (success) {
                            threatBtn.style.background = 'rgba(239, 68, 68, 0.5)';
                            threatBtn.style.borderColor = '#ef4444';
                            threatBtn.disabled = true;
                            threatBtn.style.opacity = '1';
                            threatBtn.style.cursor = 'not-allowed';
                        }
                    });

                    investigateBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        window.location.href = `/geospatial.html?bssid=${encodeURIComponent(threat.bssid)}&ssid=${encodeURIComponent(threat.ssid || '')}`;
                    });

                    wigleBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        wigleBtn.textContent = '‚è≥ Loading...';
                        wigleBtn.disabled = true;
                        
                        try {
                            const response = await fetch(`${API_BASE}/wigle/live/${threat.bssid}`);
                            const data = await response.json();
                            
                            if (data.network) {
                                const net = data.network;
                                alert(`WiGLE Data for ${threat.bssid}:\n\n` +
                                    `SSID: ${net.ssid || 'N/A'}\n` +
                                    `Encryption: ${net.encryption || 'N/A'}\n` +
                                    `Channel: ${net.channel || 'N/A'}\n` +
                                    `Location: ${net.city || 'N/A'}, ${net.region || 'N/A'}, ${net.country || 'N/A'}\n` +
                                    `Coordinates: ${net.trilat || net.lastlat}, ${net.trilon || net.lastlon}\n` +
                                    `First Seen: ${net.firsttime || 'N/A'}\n` +
                                    `Last Seen: ${net.lasttime || 'N/A'}\n` +
                                    `Total Results: ${data.totalResults || 0}`
                                );
                            } else {
                                alert(`No WiGLE data found for ${threat.bssid}\n\nThis network may not be in the WiGLE database.`);
                            }
                        } catch (err) {
                            alert(`Error fetching WiGLE data: ${err.message}`);
                        } finally {
                            wigleBtn.textContent = 'üåê WiGLE';
                            wigleBtn.disabled = false;
                        }
                    });

                    item.addEventListener('click', () => {
                        investigateThreat(threat.bssid, threat.ssid);
                    });

                    listEl.appendChild(item);
                });

                console.log(`‚úì Loaded ${data.threats.length} threats for investigation (page ${pagination.activeThreats.page})`);
                pagination.activeThreats.loading = false;
            } catch (err) {
                console.error('‚úó Error loading threat list:', err);
                pagination.activeThreats.loading = false;
            }
        }

        // Navigate to geospatial page with threat selected
        function investigateThreat(bssid, ssid) {
            console.log(`üéØ Investigating threat: ${ssid || 'Hidden'} (${bssid})`);
            window.location.href = `/geospatial.html?bssid=${encodeURIComponent(bssid)}&ssid=${encodeURIComponent(ssid || '')}`;
        }

        // Setup infinite scroll for all three lists
        function setupInfiniteScroll() {
            // Active Threats list
            const activeThreatsList = document.querySelector('#threat-investigation-list').parentElement;
            activeThreatsList.addEventListener('scroll', () => {
                if (pagination.activeThreats.loading || !pagination.activeThreats.hasMore) return;

                const { scrollTop, scrollHeight, clientHeight } = activeThreatsList;
                if (scrollTop + clientHeight >= scrollHeight - 100) {
                    console.log('üìú Loading more active threats...');
                    pagination.activeThreats.page++;
                    loadThreatList(true);
                }
            });

            // Confirmed Threats list
            const confirmedThreatsList = document.querySelector('#confirmed-threats-list').parentElement;
            confirmedThreatsList.addEventListener('scroll', () => {
                if (pagination.confirmedThreats.loading || !pagination.confirmedThreats.hasMore) return;

                const { scrollTop, scrollHeight, clientHeight } = confirmedThreatsList;
                if (scrollTop + clientHeight >= scrollHeight - 100) {
                    console.log('üìú Loading more confirmed threats...');
                    pagination.confirmedThreats.page++;
                    loadConfirmedThreats(true);
                }
            });

            // Tagged Safe list
            const taggedSafeList = document.querySelector('#tagged-safe-list').parentElement;
            taggedSafeList.addEventListener('scroll', () => {
                if (pagination.taggedSafe.loading || !pagination.taggedSafe.hasMore) return;

                const { scrollTop, scrollHeight, clientHeight } = taggedSafeList;
                if (scrollTop + clientHeight >= scrollHeight - 100) {
                    console.log('üìú Loading more tagged safe networks...');
                    pagination.taggedSafe.page++;
                    loadTaggedSafe(true);
                }
            });

            console.log('‚úì Infinite scroll setup complete for all three lists');
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', () => {
            highlightActiveNav();
            loadMetrics();
            loadThreatChart();
            loadTemporalChart();
            loadThreatList();
            loadConfirmedThreats();
            loadTaggedSafe();
            setupInfiniteScroll();

            // Wire up threat severity filter
            const severityFilter = document.getElementById('threat-severity-filter');
            if (severityFilter) {
                severityFilter.addEventListener('change', (e) => {
                    minThreatSeverity = e.target.value;
                    console.log(`üéöÔ∏è Threat severity filter changed to: ${minThreatSeverity}`);
                    loadThreatList();
                    // Note: chart still shows all threats for context
                });
            }
            
            // Wire up apply filters button
            const applyFiltersBtn = document.getElementById('apply-filters-btn');
            if (applyFiltersBtn) {
                applyFiltersBtn.addEventListener('click', () => {
                    console.log('üéõÔ∏è Applying custom filters...');
                    pagination.activeThreats.page = 1;
                    loadThreatList();
                });
            }
            
            // Wire up search input (real-time search)
            const searchInput = document.getElementById('threat-search');
            if (searchInput) {
                let searchTimeout;
                searchInput.addEventListener('input', () => {
                    clearTimeout(searchTimeout);
                    searchTimeout = setTimeout(() => {
                        console.log('üîç Search filter applied');
                        loadThreatList();
                    }, 300);
                });
            }
        });
    </script>
    
    
    <script src="/assets/js/radio-icons.js"></script>
    <script src="/assets/js/unified-card-library.js"></script>
    <script src="/assets/js/unified-components.js"></script>
    <script src="/assets/js/base-components.js"></script>
            }
        });
</body>
</html>