<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowCheck - Network Explorer</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            gap: 20px;
            flex-shrink: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
        }

        .logo {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #2563eb);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }

        .header-title {
            font-size: 14px;
            font-weight: 600;
        }

        .nav-links {
            display: flex;
            gap: 8px;
            justify-content: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .header-right-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            justify-content: flex-end;
        }

        .nav-link {
            border: none;
            background: rgba(59, 130, 246, 0.1);
            color: #e0e7ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s;
            border: 1px solid rgba(148, 163, 184, 0.2);
            text-decoration: none;
            display: inline-block;
        }

        .nav-link:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(148, 163, 184, 0.4);
        }

        .nav-link.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #cbd5e1;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .main {
            flex: 1;
            overflow: hidden;
            padding: 12px;
        }

        .panel {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            height: 100%;
            overflow: hidden;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            font-size: 13px;
            font-weight: 600;
            color: #cbd5e1;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 12px;
            flex-wrap: wrap;
        }

        .panel-count {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 11px;
            font-weight: 600;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 0;
        }

        .controls {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        input[type="search"] {
            background: rgba(30, 41, 59, 0.6);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: #f8fafc;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            min-width: 200px;
        }

        button {
            border: none;
            background: rgba(59, 130, 246, 0.1);
            color: #e0e7ff;
            padding: 8px 12px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        button:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(148, 163, 184, 0.4);
        }

        .network-table {
            width: 100%;
            font-size: 12px;
            border-collapse: collapse;
        }

        .network-table thead {
            position: sticky;
            top: 0;
            background: rgba(30, 41, 59, 0.95);
            border-bottom: 2px solid rgba(148, 163, 184, 0.2);
            z-index: 10;
        }

        .network-table th {
            padding: 12px 16px;
            text-align: left;
            color: #94a3b8;
            font-weight: 600;
            white-space: nowrap;
        }

        .network-table td {
            padding: 10px 16px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 200px;
        }

        .network-table tr:hover {
            background: rgba(59, 130, 246, 0.05);
            cursor: pointer;
        }

        .network-ssid {
            color: #60a5fa;
            font-weight: 600;
        }

        .network-bssid {
            color: #94a3b8;
            font-size: 11px;
            font-family: 'Courier New', monospace;
        }

        .badge {
            display: inline-block;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 10px;
            font-weight: 600;
        }

        .badge-wifi {
            background: rgba(59, 130, 246, 0.2);
            color: #60a5fa;
        }

        .badge-ble {
            background: rgba(139, 92, 246, 0.2);
            color: #a78bfa;
        }

        .signal-strong {
            color: #10b981;
            font-weight: 600;
        }

        .signal-medium {
            color: #f59e0b;
            font-weight: 600;
        }

        .signal-weak {
            color: #ef4444;
            font-weight: 600;
        }

        ::-webkit-scrollbar {
            width: 8px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.3);
            border-radius: 4px;
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 12px;
            padding: 40px;
        }

        /* Column Selector Styles */
        .column-selector {
            position: relative;
            display: inline-block;
        }

        .column-selector-btn {
            padding: 8px 12px;
            font-size: 12px;
        }

        .column-selector-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: rgba(30, 41, 59, 0.95);
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            min-width: 200px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .column-selector-header {
            padding: 12px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 12px;
            font-weight: 600;
            color: #cbd5e1;
        }

        .reset-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(239, 68, 68, 0.2);
            color: #fca5a5;
            border: 1px solid rgba(239, 68, 68, 0.3);
        }

        .reset-btn:hover {
            background: rgba(239, 68, 68, 0.3);
        }

        .column-selector-list {
            padding: 8px;
            max-height: 400px;
            overflow-y: auto;
        }

        .column-selector-item {
            display: flex;
            align-items: center;
            padding: 8px;
            gap: 8px;
            cursor: pointer;
            border-radius: 4px;
            transition: background 0.2s;
        }

        .column-selector-item:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .column-selector-item input[type="checkbox"] {
            cursor: pointer;
        }

        .column-selector-item span {
            color: #e0e7ff;
        }

        /* Sortable Table Headers */
        .network-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 24px;
        }

        .network-table th.sortable:hover {
            background: rgba(59, 130, 246, 0.15);
        }

        .network-table th .sort-indicator {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #60a5fa;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .network-table th.sorted .sort-indicator {
            opacity: 1;
        }

        .network-table th.sortable:hover .sort-indicator {
            opacity: 0.5;
        }

        /* Network Table Enhancements */
        .network-table tbody tr {
            transition: background-color 0.2s;
        }

        .network-table tbody tr:nth-child(even) {
            background: rgba(30, 41, 59, 0.3);
        }

        .network-table tbody tr:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .network-table td.mono {
            font-family: 'SF Mono', 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .network-count-info {
            font-size: 11px;
            color: #94a3b8;
            margin-left: 8px;
        }

        /* Threat Level Indicators */
        .threat-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .threat-indicator.threat {
            background: #ef4444;
            box-shadow: 0 0 8px rgba(239, 68, 68, 0.6);
        }

        .threat-indicator.warning {
            background: #f59e0b;
            box-shadow: 0 0 8px rgba(245, 158, 11, 0.6);
        }

        .threat-indicator.safe {
            background: #10b981;
            box-shadow: 0 0 8px rgba(16, 185, 129, 0.6);
        }

        /* Removed threat level borders - using badges instead */
    </style>
</head>
<body>
    <div class="container">
        <!-- HEADER -->
        <div class="header">
            <div class="header-left">
                <div class="logo">üåê</div>
                <div class="header-title">Network Explorer</div>
            </div>
            <div class="nav-links">
                <a href="/" class="nav-link" data-page="dashboard">Dashboard</a>
                <a href="/geospatial.html" class="nav-link" data-page="geospatial">Geospatial</a>
                <a href="/analytics.html" class="nav-link" data-page="analytics">Analytics</a>
                <a href="/surveillance.html" class="nav-link" data-page="surveillance">Surveillance</a>
                <a href="/networks.html" class="nav-link active" data-page="networks">Networks</a>
            </div>
            <div class="header-right-group">
                <div class="status">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
                <div class="controls">
                    <input type="search" id="search-input" placeholder="Search SSID or BSSID...">
                    <select id="threat-filter" style="background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; padding: 8px 12px; border-radius: 6px; font-size: 12px;">
                        <option value="">All Threats</option>
                        <option value="threat">üî¥ Threats Only</option>
                        <option value="warning">üü° Warnings Only</option>
                        <option value="safe">üü¢ Safe Only</option>
                    </select>
                    <button id="refresh-btn">üîÑ Refresh</button>
                </div>
            </div>
        </div>

        <!-- MAIN -->
        <div class="main">
            <div class="panel">
                <div class="panel-header">
                    üì° All Networks
                    <span class="panel-count" id="network-count">0</span>
                    <span class="network-count-info" id="network-count-info"></span>
                    <span style="font-size: 10px; color: #94a3b8; margin-left: 12px;">üí° Click headers to sort ‚Ä¢ Shift+Click for multi-column</span>
                    <div id="column-selector-container"></div>
                </div>
                <div class="panel-content">
                    <table class="network-table" id="networks-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>SSID</th>
                                <th>BSSID</th>
                                <th>Signal</th>
                                <th>Security</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td colspan="6" class="loading">Loading networks...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Use dynamic API base URL based on current window location
        const API_BASE = `${window.location.protocol}//${window.location.hostname}:3002/api`;

        // Advanced Network Table Configuration (Full Schema)
        const NETWORK_COLUMNS = {
            type: {
                label: 'Type',
                width: '80px',
                sortable: true,
                default: true,
                format: (val) => {
                    const typeConfig = {
                        'W': { label: 'WiFi', icon: 'üì∂', color: '#60a5fa', bg: 'rgba(59, 130, 246, 0.2)' },
                        'E': { label: 'BLE', icon: 'üîµ', color: '#a78bfa', bg: 'rgba(139, 92, 246, 0.2)' },
                        'B': { label: 'BT', icon: 'üî∑', color: '#818cf8', bg: 'rgba(129, 140, 248, 0.2)' },
                        'L': { label: 'LTE', icon: 'üì±', color: '#34d399', bg: 'rgba(52, 211, 153, 0.2)' },
                        'N': { label: '5G', icon: 'üöÄ', color: '#fbbf24', bg: 'rgba(251, 191, 36, 0.2)' },
                        'G': { label: 'GSM', icon: 'üìû', color: '#fb923c', bg: 'rgba(251, 146, 60, 0.2)' }
                    };
                    const config = typeConfig[val] || typeConfig['W'];
                    return `<span class="badge" style="background: ${config.bg}; color: ${config.color}; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600;">${config.icon} ${config.label}</span>`;
                }
            },
            ssid: {
                label: 'SSID',
                width: '150px',
                sortable: true,
                default: true,
                format: (val) => val || '(hidden)'
            },
            bssid: {
                label: 'BSSID',
                width: '120px',
                sortable: true,
                default: true,
                monospace: true,
                format: (val) => val || 'N/A'
            },
            signal: {
                label: 'Signal (dBm)',
                width: '100px',
                sortable: true,
                default: true,
                format: (val) => {
                    if (val === null || val === undefined) return 'N/A';
                    const strength = parseFloat(val);
                    let colorClass, bgColor, textColor;

                    if (strength >= -50) {
                        // Strong signal
                        colorClass = 'signal-strong';
                        bgColor = 'rgba(34, 197, 94, 0.2)';
                        textColor = '#4ade80';
                    } else if (strength >= -70) {
                        // Medium signal
                        colorClass = 'signal-medium';
                        bgColor = 'rgba(234, 179, 8, 0.2)';
                        textColor = '#fde047';
                    } else {
                        // Weak signal
                        colorClass = 'signal-weak';
                        bgColor = 'rgba(239, 68, 68, 0.2)';
                        textColor = '#fca5a5';
                    }

                    return `<span class="${colorClass}" style="background: ${bgColor}; color: ${textColor}; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600;">${val} dBm</span>`;
                },
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : -999
            },
            security: {
                label: 'Security',
                width: '140px',
                sortable: true,
                default: true,
                format: (val) => val || 'Unknown'
            },
            manufacturer: {
                label: 'Manufacturer',
                width: '150px',
                sortable: true,
                default: true,
                format: (val) => val || 'Unknown'
            },
            frequency: {
                label: 'Frequency (GHz)',
                width: '120px',
                sortable: true,
                default: false,
                format: (val) => val ? `${parseFloat(val).toFixed(3)} GHz` : 'N/A',
                sortValue: (val) => val ? parseFloat(val) : 0
            },
            channel: {
                label: 'Channel',
                width: '80px',
                sortable: true,
                default: false,
                format: (val) => val || 'N/A'
            },
            observations: {
                label: 'Observations',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => {
                    const count = val || '1';
                    return `<span style="background: rgba(59, 130, 246, 0.2); color: #60a5fa; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; border: 1px solid rgba(59, 130, 246, 0.3);">${count}</span>`;
                },
                sortValue: (val) => val ? parseInt(val) : 1
            },
            latitude: {
                label: 'Latitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            longitude: {
                label: 'Longitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            distanceFromHome: {
                label: 'Distance (km)',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(2)} km` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 999999
            },
            accuracy: {
                label: 'Accuracy (m)',
                width: '100px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(1)} m` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            lastSeen: {
                label: 'Last Seen',
                width: '160px',
                sortable: true,
                default: true,
                format: (val) => {
                    if (!val) return 'Unknown';
                    try {
                        const date = new Date(parseInt(val));
                        return date.toLocaleString();
                    } catch (e) {
                        return 'Unknown';
                    }
                },
                sortValue: (val) => {
                    if (!val) return 0;
                    return typeof val === 'number' ? val : new Date(val).getTime();
                }
            },
            misc: {
                label: 'Misc',
                width: '200px',
                sortable: false,
                default: false,
                format: (val) => val || ''
            }
        };

        // Network Table State Management
        class NetworkTableManager {
            constructor(pageId) {
                this.pageId = pageId;
                this.storageKey = `networkListColumns-${pageId}`;
                this.networks = [];
                this.currentSort = [{ column: 'lastSeen', direction: 'desc' }]; // Array for multi-column sort
                this.visibleColumns = this.loadColumnPreferences();
                this.searchTerm = '';
                this.threatFilter = ''; // '' = all, 'threat', 'warning', 'safe'
                this.currentPage = 1;
                this.totalNetworks = 0;
                this.currentLimit = 100; // Matches API default
            }

            // Load column visibility preferences from localStorage
            loadColumnPreferences() {
                const saved = localStorage.getItem(this.storageKey);
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading column preferences:', e);
                    }
                }
                // Return default columns
                return Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
            }

            // Save column visibility preferences to localStorage
            saveColumnPreferences() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.visibleColumns));
            }

            // Reset to default columns
            resetToDefaults() {
                this.visibleColumns = Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
                this.saveColumnPreferences();
            }

            // Toggle column visibility
            toggleColumn(columnKey) {
                const index = this.visibleColumns.indexOf(columnKey);
                if (index > -1) {
                    this.visibleColumns.splice(index, 1);
                } else {
                    this.visibleColumns.push(columnKey);
                }
                this.saveColumnPreferences();
            }

            // Set sort column (supports multi-column with Shift key)
            setSort(column, shiftKey = false) {
                if (!NETWORK_COLUMNS[column] || !NETWORK_COLUMNS[column].sortable) return;

                if (shiftKey) {
                    // Multi-column sort: add/update this column in the sort array
                    const existingIndex = this.currentSort.findIndex(s => s.column === column);
                    if (existingIndex > -1) {
                        // Toggle direction for existing column
                        if (this.currentSort[existingIndex].direction === 'asc') {
                            this.currentSort[existingIndex].direction = 'desc';
                        } else {
                            // Remove this column from sort
                            this.currentSort.splice(existingIndex, 1);
                        }
                    } else {
                        // Add new column to sort
                        this.currentSort.push({ column, direction: 'asc' });
                    }
                } else {
                    // Single column sort
                    const existing = this.currentSort.find(s => s.column === column);
                    if (existing && this.currentSort.length === 1) {
                        // Toggle direction
                        existing.direction = existing.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        // Replace with new single column sort
                        this.currentSort = [{ column, direction: 'asc' }];
                    }
                }
                loadNetworks(); // Reload networks with new sort
            }

            // Apply search filter
            setSearch(term) {
                this.searchTerm = term.toLowerCase();
                this.currentPage = 1; // Reset page on new search
                loadNetworks(); // Reload networks with new search term
            }

            // Apply threat level filter
            setThreatFilter(level) {
                this.threatFilter = level;
                this.currentPage = 1; // Reset page on new filter
                loadNetworks(); // Reload networks with new filter
            }

            // Load more networks (for infinite scroll)
            loadMore() {
                this.currentPage++;
                loadNetworks(true); // append = true
            }

            // Check if more networks available
            hasMore() {
                return (this.currentPage * this.currentLimit) < this.totalNetworks;
            }

            // Set networks data
            setNetworks(data) {
                this.networks = data.networks;
                this.totalNetworks = data.totalCount;
                this.currentPage = data.page;
                this.currentLimit = data.limit;
            }

            // Render column selector UI
            renderColumnSelector(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                const html = `
                    <div class="column-selector">
                        <button class="column-selector-btn" onclick="toggleColumnSelectorDropdown()">
                            ‚öôÔ∏è Columns
                        </button>
                        <div class="column-selector-dropdown" id="column-selector-dropdown" style="display: none;">
                            <div class="column-selector-header">
                                <span>Show/Hide Columns</span>
                                <button onclick="networkTable.resetToDefaults(); renderNetworkTable();" class="reset-btn">Reset</button>
                            </div>
                            <div class="column-selector-list">
                                ${Object.keys(NETWORK_COLUMNS).map(key => `
                                    <label class="column-selector-item">
                                        <input
                                            type="checkbox"
                                            ${this.visibleColumns.includes(key) ? 'checked' : ''}
                                            onchange="networkTable.toggleColumn('${key}'); renderNetworkTable();"
                                        />
                                        <span>${NETWORK_COLUMNS[key].label}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;

                container.innerHTML = html;
            }
        }

        // Toggle column selector dropdown
        function toggleColumnSelectorDropdown() {
            const dropdown = document.getElementById('column-selector-dropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('column-selector-dropdown');
            const btn = document.querySelector('.column-selector-btn');
            if (dropdown && btn && !dropdown.contains(e.target) && !btn.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Render network table with current settings
        function renderNetworkTable(tableId = 'networks-table', onRowClick = null, append = false) {
            if (!window.networkTable) return;

            const table = document.getElementById(tableId);
            if (!table) return;

            const tbody = table.querySelector('tbody');
            const thead = table.querySelector('thead');
            if (!tbody || !thead) return;

            // Render table headers (unless appending)
            if (!append) {
                const headerRow = document.createElement('tr');
                networkTable.visibleColumns.forEach(colKey => {
                    const col = NETWORK_COLUMNS[colKey];
                    const th = document.createElement('th');
                    th.style.width = col.width;
                    th.textContent = col.label;

                    if (col.sortable) {
                        th.className = 'sortable';
                        th.onclick = (e) => {
                            networkTable.setSort(colKey, e.shiftKey);
                            renderNetworkTable(tableId, onRowClick);
                        };

                        // Add sort indicator
                        const sortIndex = networkTable.currentSort.findIndex(s => s.column === colKey);
                        if (sortIndex > -1) {
                            th.classList.add('sorted');
                            const indicator = document.createElement('span');
                            indicator.className = 'sort-indicator';
                            const sort = networkTable.currentSort[sortIndex];
                            indicator.textContent = sort.direction === 'asc' ? '‚ñ≤' : '‚ñº';
                            if (networkTable.currentSort.length > 1) {
                                indicator.textContent += ` ${sortIndex + 1}`;
                            }
                            th.appendChild(indicator);
                        } else {
                            const indicator = document.createElement('span');
                            indicator.className = 'sort-indicator';
                            indicator.textContent = '‚ñ≤';
                            th.appendChild(indicator);
                        }
                    }

                    headerRow.appendChild(th);
                });
                thead.innerHTML = '';
                thead.appendChild(headerRow);
            }

            // Clear body if not appending
            if (!append) {
                tbody.innerHTML = '';
            }

            // Check if empty
            if (networkTable.networks.length === 0 && !append) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = networkTable.visibleColumns.length;
                td.className = 'loading';
                td.textContent = networkTable.searchTerm ? 'No networks found matching search' : 'No networks found';
                tr.appendChild(td);
                tbody.appendChild(tr);
                return;
            }

            // Render networks
            networkTable.networks.forEach(network => { // Iterate over networkTable.networks directly
                // Apply threat filter
                if (networkTable.threatFilter && network.status !== networkTable.threatFilter) {
                    return; // Skip networks that don't match the filter
                }

                const tr = document.createElement('tr');
                tr.dataset.bssid = network.bssid;

                // Add click handler if provided
                if (onRowClick) {
                    tr.style.cursor = 'pointer';
                    tr.onclick = () => onRowClick(network);
                }

                networkTable.visibleColumns.forEach((colKey, index) => {
                    const col = NETWORK_COLUMNS[colKey];
                    const td = document.createElement('td');

                    // Get value from network data
                    let value = network[colKey];

                    // Special handling for latitude/longitude from location object
                    if (colKey === 'latitude' && network.location) {
                        value = network.location.lat;
                    } else if (colKey === 'longitude' && network.location) {
                        value = network.location.lng;
                    }

                    // Format value
                    td.innerHTML = col.format ? col.format(value) : (value || 'N/A');

                    // Apply monospace style if needed
                    if (col.monospace) {
                        td.className = 'mono';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            // Update count display
            updateNetworkCount();
        }

        // Update network count display
        function updateNetworkCount() {
            if (!window.networkTable) return;

            const countEl = document.getElementById('network-count');
            const infoEl = document.getElementById('network-count-info');

            const total = networkTable.totalNetworks;
            const currentDisplayed = networkTable.networks.length;

            countEl.textContent = currentDisplayed;
            if (networkTable.searchTerm) {
                if (infoEl) infoEl.textContent = `of ${total} (filtered)`;
            } else {
                if (infoEl) infoEl.textContent = `of ${total}`;
            }
        }

        // Highlight active nav
        function highlightActiveNav() {
            const currentPath = window.location.pathname;
            document.querySelectorAll('a.nav-link').forEach(link => {
                link.classList.remove('active');
                const href = link.getAttribute('href');

                if ((currentPath === '/' || currentPath === '/index.html') && (href === '/' || href === '/index.html')) {
                    link.classList.add('active');
                } else if (href !== '/' && currentPath.includes(href.replace('/', ''))) {
                    link.classList.add('active');
                }
            });
        }

        // Load networks from API
        async function loadNetworks(append = false) { // Add append parameter
            try {
                // Initialize table manager if not exists
                if (!window.networkTable) {
                    window.networkTable = new NetworkTableManager('networks');
                }

                // Construct URL with parameters
                const params = new URLSearchParams();
                params.append('page', networkTable.currentPage);
                params.append('limit', networkTable.currentLimit);
                const primarySort = networkTable.currentSort[0] || { column: 'lastSeen', direction: 'desc' };
                params.append('sort', primarySort.column);
                params.append('order', (primarySort.direction || 'desc').toUpperCase());
                if (networkTable.searchTerm) {
                    params.append('search', networkTable.searchTerm);
                }

                console.log(`üì° Loading networks with all fields: ${API_BASE}/networks?${params.toString()}`);
                const response = await fetch(`${API_BASE}/networks?${params.toString()}`);

                if (!response.ok) {
                    console.error('‚úó Networks API failed:', response.status);
                    return;
                }

                const data = await response.json(); // API now returns {networks, totalCount, page, limit}
                console.log(`‚úì Loaded ${data.networks?.length || 0} networks, Total: ${data.totalCount}`);

                if (!data.networks || data.networks.length === 0) {
                    console.warn('‚ö†Ô∏è No networks returned from API');
                    const tbody = document.querySelector('#networks-table tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="6" class="loading">No networks found</td></tr>';
                    }
                    return;
                }

                if (append) {
                    // Append new networks to existing list
                    networkTable.networks = networkTable.networks.concat(data.networks);
                    networkTable.totalNetworks = data.totalCount; // Update total count
                    networkTable.currentPage = data.page;
                    networkTable.currentLimit = data.limit;
                } else {
                    // Set networks and render
                    networkTable.setNetworks(data);
                }
                
                networkTable.renderColumnSelector('column-selector-container');
                renderNetworkTable('networks-table', null, append); // Pass append to render
            } catch (error) {
                console.error('‚úó Error loading networks:', error);
            }
        }

        // Search functionality with debounce
        let searchTimeout;
        document.getElementById('search-input').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (window.networkTable) {
                    networkTable.setSearch(e.target.value);
                    renderNetworkTable();
                }
            }, 300);
        });

        // Threat filter functionality
        document.getElementById('threat-filter').addEventListener('change', (e) => {
            if (window.networkTable) {
                networkTable.setThreatFilter(e.target.value);
                renderNetworkTable();
            }
        });

        // Refresh button
        document.getElementById('refresh-btn').addEventListener('click', () => {
            loadNetworks();
            document.getElementById('search-input').value = '';
            document.getElementById('threat-filter').value = '';
        });

        // Setup infinite scroll
        function setupInfiniteScroll() {
            const panelContent = document.querySelector('.panel-content');
            if (!panelContent) return;

            let isLoading = false;

            panelContent.addEventListener('scroll', () => {
                if (isLoading || !window.networkTable) return;

                const { scrollTop, scrollHeight, clientHeight } = panelContent;

                // Trigger when 200px from bottom
                if (scrollTop + clientHeight >= scrollHeight - 200) {
                    if (networkTable.hasMore()) {
                        isLoading = true;
                        console.log(`üìú Loading more networks (${networkTable.networks.length}/${networkTable.totalNetworks})`);

                        networkTable.loadMore();
                        // No need to call renderNetworkTable here, loadNetworks already does it.

                        setTimeout(() => { isLoading = false; }, 100);
                    }
                }
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            highlightActiveNav();
            loadNetworks();
            setupInfiniteScroll();
        });
    </script>
</body>
</html>