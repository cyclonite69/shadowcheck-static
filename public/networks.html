<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowCheck - Networks</title>
    <link rel="stylesheet" href="/assets/styles/unified.css">
</head>
<body data-page="networks">
    <div class="app-container">
        <header class="app-header">
            <div class="header-left">
                <div class="logo">SC</div>
                <span class="font-semibold">ShadowCheck</span>
            </div>
            <nav class="nav-links">
                <a href="/" class="nav-link">Dashboard</a>
                <a href="/networks.html" class="nav-link active">Networks</a>
                <a href="/geospatial.html" class="nav-link">Geospatial</a>
                <a href="/surveillance.html" class="nav-link">Surveillance</a>
                <a href="/analytics.html" class="nav-link">Analytics</a>
                <a href="/admin.html" class="nav-link">Admin</a>
            </nav>
            <div class="header-right">
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </header>

        <main class="app-main">
<div class="main">
            <div class="panel">
                <div class="panel-header">
                    üì° All Networks
                    <span class="panel-count" id="network-count">Loading...</span>
                    <span class="network-count-info" id="network-count-info"></span>
                    <button id="show-on-map-btn" style="margin-left: 12px; padding: 6px 12px; background: rgba(59, 130, 246, 0.2); border: 1px solid rgba(59, 130, 246, 0.4); border-radius: 6px; color: #60a5fa; font-size: 11px; font-weight: 600; cursor: pointer; display: none;" onclick="showSelectedOnMap()">üó∫Ô∏è Show <span id="selected-count">0</span> on Map</button>
                    <div id="column-selector-container"></div>
                </div>
                <div class="panel-content">
                    <table class="network-table" id="networks-table">
                        <thead>
                            <tr>
                                <th>Type</th>
                                <th>SSID</th>
                                <th>BSSID</th>
                                <th>Signal</th>
                                <th>Security</th>
                                <th>Last Seen</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td colspan="6" class="loading">Loading networks...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Use dynamic API base URL based on current window location
        const API_BASE = Object.freeze(`${window.location.protocol}//${window.location.hostname}:3001/api`);

        // Advanced Network Table Configuration (matches geospatial.html)
        const NETWORK_COLUMNS = {
            select: {
                label: '<input type="checkbox" id="select-all-checkbox" onclick="toggleSelectAll()" style="cursor:pointer">',
                width: '40px',
                sortable: false,
                default: true,
                format: (val, network) => `<input type="checkbox" class="network-checkbox" data-bssid="${network.bssid}" onchange="updateSelectionCount()" onclick="event.stopPropagation()">`
            },
            type: {
                label: 'Type',
                width: '80px',
                sortable: true,
                default: true,
                format: (val) => {
                    const types = {
                        'W': { label: 'WiFi', icon: 'üì∂', color: '#3b82f6' },
                        'E': { label: 'BLE', icon: 'üîµ', color: '#8b5cf6' },
                        'B': { label: 'BT', icon: 'üîµ', color: '#3b82f6' },
                        'L': { label: 'LTE', icon: 'üì°', color: '#10b981' },
                        'N': { label: '5G', icon: 'üöÄ', color: '#f59e0b' },
                        'G': { label: 'GSM', icon: 'üìû', color: '#6b7280' }
                    };
                    const t = types[val] || types['W'];
                    return `<span style="display:inline-flex;align-items:center;gap:4px;padding:4px 8px;background:${t.color}22;border:1px solid ${t.color}44;border-radius:6px;font-size:11px;font-weight:500;color:${t.color}"><span>${t.icon}</span><span>${t.label}</span></span>`;
                }
            },
            ssid: {
                label: 'SSID',
                width: '150px',
                sortable: true,
                default: true,
                format: (val) => val || '(hidden)'
            },
            bssid: {
                label: 'BSSID',
                width: '120px',
                sortable: true,
                default: true,
                monospace: true,
                format: (val) => val || 'N/A'
            },
            signal: {
                label: 'Signal (dBm)',
                width: '100px',
                sortable: true,
                default: true,
                format: (val) => {
                    if (val === null || val === undefined) return 'N/A';
                    let color = '#6b7280'; // gray default
                    if (val >= -50) color = '#10b981'; // green - strong
                    else if (val >= -70) color = '#f59e0b'; // orange - medium
                    else color = '#ef4444'; // red - weak
                    return `<span style="color:${color};font-weight:600">${val} dBm</span>`;
                },
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : -999
            },
            security: {
                label: 'Security',
                width: '140px',
                sortable: true,
                default: true,
                format: (val) => val || 'Unknown'
            },
            frequency: {
                label: 'Frequency (GHz)',
                width: '120px',
                sortable: true,
                default: false,
                format: (val) => val ? `${parseFloat(val).toFixed(3)} GHz` : 'N/A',
                sortValue: (val) => val ? parseFloat(val) : 0
            },
            channel: {
                label: 'Channel',
                width: '80px',
                sortable: true,
                default: false,
                format: (val) => val || 'N/A'
            },
            observations: {
                label: 'Observations',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => {
                    const count = val || '1';
                    return `<span style="background: rgba(59, 130, 246, 0.2); color: #60a5fa; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; border: 1px solid rgba(59, 130, 246, 0.3);">${count}</span>`;
                },
                sortValue: (val) => val ? parseInt(val) : 1
            },
            latitude: {
                label: 'Latitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            longitude: {
                label: 'Longitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            distanceFromHome: {
                label: 'Distance (km)',
                width: '110px',
                sortable: true,
                default: true,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(2)} km` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 999999
            },
            accuracy: {
                label: 'Accuracy (m)',
                width: '100px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(1)} m` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            lastSeen: {
                label: 'Last Seen',
                width: '160px',
                sortable: true,
                default: true,
                format: (val) => {
                    if (!val) return 'Unknown';
                    try {
                        const date = new Date(parseInt(val));
                        return date.toLocaleString();
                    } catch (e) {
                        return 'Unknown';
                    }
                },
                sortValue: (val) => {
                    if (!val) return 0;
                    return typeof val === 'number' ? val : new Date(val).getTime();
                }
            },
            misc: {
                label: 'Misc',
                width: '200px',
                sortable: false,
                default: false,
                format: (val) => val || ''
            }
        };

        // Network Table State Management
        class NetworkTableManager {
            constructor(pageId) {
                this.pageId = pageId;
                this.storageKey = `networkListColumns-${pageId}`;
                this.networks = [];
                this.currentSort = [{ column: 'lastSeen', direction: 'desc' }]; // Array for multi-column sort
                this.visibleColumns = this.loadColumnPreferences();
                this.searchTerm = '';
                this.threatFilter = ''; // '' = all, 'threat', 'warning', 'safe'
                this.currentPage = 1;
                this.totalNetworks = 0;
                this.currentLimit = 100; // Matches API default
            }

            // Load column visibility preferences from localStorage
            loadColumnPreferences() {
                const saved = localStorage.getItem(this.storageKey);
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading column preferences:', e);
                    }
                }
                // Return default columns
                return Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
            }

            // Save column visibility preferences to localStorage
            saveColumnPreferences() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.visibleColumns));
            }

            // Reset to default columns
            resetToDefaults() {
                this.visibleColumns = Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
                this.saveColumnPreferences();
            }

            // Toggle column visibility
            toggleColumn(columnKey) {
                const index = this.visibleColumns.indexOf(columnKey);
                if (index > -1) {
                    this.visibleColumns.splice(index, 1);
                } else {
                    this.visibleColumns.push(columnKey);
                }
                this.saveColumnPreferences();
            }

            // Set sort column (supports multi-column with Shift key)
            setSort(column, shiftKey = false) {
                if (!NETWORK_COLUMNS[column] || !NETWORK_COLUMNS[column].sortable) return;

                if (shiftKey) {
                    // Multi-column sort: add/update this column in the sort array
                    const existingIndex = this.currentSort.findIndex(s => s.column === column);
                    if (existingIndex > -1) {
                        // Toggle direction for existing column
                        if (this.currentSort[existingIndex].direction === 'asc') {
                            this.currentSort[existingIndex].direction = 'desc';
                        } else {
                            // Remove this column from sort
                            this.currentSort.splice(existingIndex, 1);
                        }
                    } else {
                        // Add new column to sort
                        this.currentSort.push({ column, direction: 'asc' });
                    }
                } else {
                    // Single column sort
                    const existing = this.currentSort.find(s => s.column === column);
                    if (existing && this.currentSort.length === 1) {
                        // Toggle direction
                        existing.direction = existing.direction === 'asc' ? 'desc' : 'asc';
                    } else {
                        // Replace with new single column sort
                        this.currentSort = [{ column, direction: 'asc' }];
                    }
                }
                loadNetworks(); // Reload networks with new sort
            }

            // Apply search filter
            setSearch(term) {
                this.searchTerm = term.toLowerCase();
                this.currentPage = 1; // Reset page on new search
                loadNetworks(); // Reload networks with new search term
            }

            // Apply threat level filter
            setThreatFilter(level) {
                this.threatFilter = level;
                this.currentPage = 1; // Reset page on new filter
                loadNetworks(); // Reload networks with new filter
            }

            // Load more networks (for infinite scroll)
            loadMore() {
                this.currentPage++;
                loadNetworks(true); // append = true
            }

            // Check if more networks available
            hasMore() {
                return (this.currentPage * this.currentLimit) < this.totalNetworks;
            }

            // Set networks data
            setNetworks(data) {
                this.networks = data.networks;
                this.totalNetworks = data.totalCount;
                this.currentPage = data.page;
                this.currentLimit = data.limit;
            }

            // Render column selector UI
            renderColumnSelector(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                const html = `
                    <div class="column-selector">
                        <button class="column-selector-btn" onclick="toggleColumnSelectorDropdown()">
                            ‚öôÔ∏è Columns
                        </button>
                        <div class="column-selector-dropdown" id="column-selector-dropdown" style="display: none;">
                            <div class="column-selector-header">
                                <span>Show/Hide Columns</span>
                                <button onclick="networkTable.resetToDefaults(); renderNetworkTable();" class="reset-btn">Reset</button>
                            </div>
                            <div class="column-selector-list">
                                ${Object.keys(NETWORK_COLUMNS).map(key => `
                                    <label class="column-selector-item">
                                        <input
                                            type="checkbox"
                                            ${this.visibleColumns.includes(key) ? 'checked' : ''}
                                            onchange="networkTable.toggleColumn('${key}'); renderNetworkTable();"
                                        />
                                        <span>${NETWORK_COLUMNS[key].label}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;

                container.innerHTML = html;
            }
        }

        // Toggle column selector dropdown
        function toggleColumnSelectorDropdown() {
            const dropdown = document.getElementById('column-selector-dropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('column-selector-dropdown');
            const btn = document.querySelector('.column-selector-btn');
            if (dropdown && btn && !dropdown.contains(e.target) && !btn.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Generate network tooltip (same as geospatial.html)
        function generateNetworkTooltip(network) {
            const signal = network.signal || 'N/A';
            let signalClass = '';
            if (signal !== 'N/A') {
                if (signal >= -50) signalClass = 'signal-strong';
                else if (signal >= -70) signalClass = 'signal-medium';
                else signalClass = 'signal-weak';
            }

            const distanceFromHome = network.distance_from_home 
                ? `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(network.distance_from_home).toFixed(2)} km</span></div>`
                : '';

            const manufacturer = network.manufacturer 
                ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${network.manufacturer}</span></div>`
                : '';

            return `
                <div class="dark-tooltip">
                    <div class="tooltip-header">
                        <span class="tooltip-ssid">${network.ssid || '(hidden)'}</span>
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">BSSID:</span>
                        <span class="tooltip-value mono">${network.bssid}</span>
                    </div>
                    ${manufacturer}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Signal:</span>
                        <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">Security:</span>
                        <span class="tooltip-value">${network.security || 'Unknown'}</span>
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">Type:</span>
                        <span class="tooltip-value">${network.type || 'WiFi'}</span>
                    </div>
                    ${distanceFromHome}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Observations:</span>
                        <span class="tooltip-value">${network.observations || '1'}</span>
                    </div>
                </div>
            `;
        }

        // Render network table with current settings
        function renderNetworkTable(tableId = 'networks-table', onRowClick = null, append = false) {
            if (!window.networkTable) return;

            const table = document.getElementById(tableId);
            if (!table) return;

            const tbody = table.querySelector('tbody');
            const thead = table.querySelector('thead');
            if (!tbody || !thead) return;

            // Render table headers (unless appending)
            if (!append) {
                const headerRow = document.createElement('tr');
                networkTable.visibleColumns.forEach(colKey => {
                    const col = NETWORK_COLUMNS[colKey];
                    const th = document.createElement('th');
                    th.style.width = col.width;
                    th.textContent = col.label;

                    if (col.sortable) {
                        th.className = 'sortable';
                        th.onclick = (e) => {
                            networkTable.setSort(colKey, e.shiftKey);
                            renderNetworkTable(tableId, onRowClick);
                        };

                        // Add sort indicator
                        const sortIndex = networkTable.currentSort.findIndex(s => s.column === colKey);
                        if (sortIndex > -1) {
                            th.classList.add('sorted');
                            const indicator = document.createElement('span');
                            indicator.className = 'sort-indicator';
                            const sort = networkTable.currentSort[sortIndex];
                            indicator.textContent = sort.direction === 'asc' ? '‚ñ≤' : '‚ñº';
                            if (networkTable.currentSort.length > 1) {
                                indicator.textContent += ` ${sortIndex + 1}`;
                            }
                            th.appendChild(indicator);
                        } else {
                            const indicator = document.createElement('span');
                            indicator.className = 'sort-indicator';
                            indicator.textContent = '‚ñ≤';
                            th.appendChild(indicator);
                        }
                    }

                    headerRow.appendChild(th);
                });
                thead.innerHTML = '';
                thead.appendChild(headerRow);
            }

            // Clear body if not appending
            if (!append) {
                tbody.innerHTML = '';
            }

            // Check if empty
            if (networkTable.networks.length === 0 && !append) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = networkTable.visibleColumns.length;
                td.className = 'loading';
                td.textContent = networkTable.searchTerm ? 'No networks found matching search' : 'No networks found';
                tr.appendChild(td);
                tbody.appendChild(tr);
                return;
            }

            // Render networks
            networkTable.networks.forEach(network => { // Iterate over networkTable.networks directly
                // Apply threat filter
                if (networkTable.threatFilter && network.status !== networkTable.threatFilter) {
                    return; // Skip networks that don't match the filter
                }

                const tr = document.createElement('tr');
                tr.dataset.bssid = network.bssid;
                tr.style.cursor = 'pointer';

                // Multi-select click handler
                tr.addEventListener('click', (e) => {
                    if (e.ctrlKey || e.metaKey) {
                        // Multi-select with Ctrl/Cmd
                        tr.classList.toggle('selected');
                    } else if (e.shiftKey && window.lastSelectedRow) {
                        // Range select with Shift
                        const rows = Array.from(tbody.querySelectorAll('tr'));
                        const start = rows.indexOf(window.lastSelectedRow);
                        const end = rows.indexOf(tr);
                        const [min, max] = [Math.min(start, end), Math.max(start, end)];
                        rows.slice(min, max + 1).forEach(r => r.classList.add('selected'));
                    } else {
                        // Single select
                        tbody.querySelectorAll('tr.selected').forEach(r => r.classList.remove('selected'));
                        tr.classList.add('selected');
                    }
                    window.lastSelectedRow = tr;

                    // Call onRowClick with all selected networks
                    if (onRowClick) {
                        const selectedBssids = Array.from(tbody.querySelectorAll('tr.selected'))
                            .map(r => r.dataset.bssid);
                        const selectedNetworks = networkTable.networks.filter(n => 
                            selectedBssids.includes(n.bssid)
                        );
                        onRowClick(selectedNetworks);
                    }
                });

                networkTable.visibleColumns.forEach((colKey, index) => {
                    const col = NETWORK_COLUMNS[colKey];
                    const td = document.createElement('td');

                    // Get value from network data
                    let value = network[colKey];

                    // Special handling for latitude/longitude from location object
                    if (colKey === 'latitude' && network.location) {
                        value = network.location.lat;
                    } else if (colKey === 'longitude' && network.location) {
                        value = network.location.lng;
                    }

                    // Format value - pass network object for select column
                    if (colKey === 'select') {
                        td.innerHTML = col.format(value, network);
                    } else {
                        td.innerHTML = col.format ? col.format(value) : (value || 'N/A');
                    }

                    // Apply monospace style if needed
                    if (col.monospace) {
                        td.className = 'mono';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            // Update count display
            updateNetworkCount();
        }

        // Update network count display
        function updateNetworkCount() {
            if (!window.networkTable) return;

            const countEl = document.getElementById('network-count');
            const infoEl = document.getElementById('network-count-info');

            const total = networkTable.totalNetworks;
            const currentDisplayed = networkTable.networks.length;

            countEl.textContent = currentDisplayed;
            if (networkTable.searchTerm) {
                if (infoEl) infoEl.textContent = `of ${total} (filtered)`;
            } else {
                if (infoEl) infoEl.textContent = `of ${total}`;
            }
        }

        // Highlight active nav
        function highlightActiveNav() {
            const currentPath = window.location.pathname;
            document.querySelectorAll('a.nav-link').forEach(link => {
                link.classList.remove('active');
                const href = link.getAttribute('href');

                if ((currentPath === '/' || currentPath === '/index.html') && (href === '/' || href === '/index.html')) {
                    link.classList.add('active');
                } else if (href !== '/' && currentPath.includes(href.replace('/', ''))) {
                    link.classList.add('active');
                }
            });
        }

        // Load networks from API
        async function loadNetworks(append = false) { // Add append parameter
            try {
                console.log('üì• loadNetworks called, append:', append);
                
                // Initialize table manager if not exists
                if (!window.networkTable) {
                    console.log('üîß Creating NetworkTableManager...');
                    window.networkTable = new NetworkTableManager('networks');
                }

                // Construct URL with parameters
                const params = new URLSearchParams();
                params.append('page', networkTable.currentPage);
                params.append('limit', networkTable.currentLimit);
                const primarySort = (networkTable.currentSort && networkTable.currentSort[0]) || { column: 'lastSeen', direction: 'desc' };
                params.append('sort', primarySort.column);
                params.append('order', (primarySort.direction || 'desc').toUpperCase());
                if (networkTable.searchTerm) {
                    params.append('search', networkTable.searchTerm);
                }

                console.log(`üì° Loading networks with all fields: ${API_BASE}/networks?${params.toString()}`);
                const response = await fetch(`${API_BASE}/networks?${params.toString()}`);

                if (!response.ok) {
                    console.error('‚úó Networks API failed:', response.status);
                    return;
                }

                const data = await response.json(); // API now returns {networks, totalCount, page, limit}
                console.log(`‚úì Loaded ${data.networks?.length || 0} networks, Total: ${data.totalCount || data.total}`);

                if (!data.networks || data.networks.length === 0) {
                    console.warn('‚ö†Ô∏è No networks returned from API');
                    const tbody = document.querySelector('#networks-table tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="6" class="loading">No networks found</td></tr>';
                    }
                    return;
                }

                // Normalize data format
                const normalizedData = {
                    networks: data.networks,
                    totalCount: data.totalCount || data.total,
                    page: data.page,
                    limit: data.limit
                };

                if (append) {
                    // Append new networks to existing list
                    networkTable.networks = networkTable.networks.concat(normalizedData.networks);
                    networkTable.totalNetworks = normalizedData.totalCount;
                    networkTable.currentPage = normalizedData.page;
                    networkTable.currentLimit = normalizedData.limit;
                } else {
                    // Set networks and render
                    networkTable.setNetworks(normalizedData);
                }
                
                networkTable.renderColumnSelector('column-selector-container');
                
                // Handler to show selected networks on geospatial map
                const handleRowClick = (selectedNetworks) => {
                    if (selectedNetworks && selectedNetworks.length > 0) {
                        const bssids = selectedNetworks.map(n => n.bssid);
                        sessionStorage.setItem('selectedNetworks', JSON.stringify(bssids));
                        window.location.href = '/geospatial.html?selected=' + encodeURIComponent(bssids.join(','));
                    }
                };
                
                renderNetworkTable('networks-table', handleRowClick, append);
                console.log('‚úÖ Networks rendered successfully');
            } catch (error) {
                console.error('‚úó Error loading networks:', error);
                const tbody = document.querySelector('#networks-table tbody');
                if (tbody) {
                    tbody.innerHTML = `<tr><td colspan="6" class="loading" style="color: #ef4444;">Error: ${error.message}</td></tr>`;
                }
            }
        }

        // Search functionality with debounce
        let searchTimeout;
        document.getElementById('search-input').addEventListener('input', (e) => {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(() => {
                if (window.networkTable) {
                    networkTable.setSearch(e.target.value);
                    renderNetworkTable();
                }
            }, 300);
        });

        // Threat filter functionality
        document.getElementById('threat-filter').addEventListener('change', (e) => {
            if (window.networkTable) {
                networkTable.setThreatFilter(e.target.value);
                renderNetworkTable();
            }
        });

        // Setup infinite scroll
        function setupInfiniteScroll() {
            const panelContent = document.querySelector('.panel-content');
            if (!panelContent) return;

            let isLoading = false;

            panelContent.addEventListener('scroll', () => {
                if (isLoading || !window.networkTable) return;

                const { scrollTop, scrollHeight, clientHeight } = panelContent;

                // Trigger when 200px from bottom
                if (scrollTop + clientHeight >= scrollHeight - 200) {
                    if (networkTable.hasMore()) {
                        isLoading = true;
                        console.log(`üìú Loading more networks (${networkTable.networks.length}/${networkTable.totalNetworks})`);

                        networkTable.loadMore();
                        // No need to call renderNetworkTable here, loadNetworks already does it.

                        setTimeout(() => { isLoading = false; }, 100);
                    }
                }
            });
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            console.log('üöÄ Networks page initializing...');
            console.log('API_BASE:', API_BASE);
            highlightActiveNav();
            console.log('üì° Calling loadNetworks()...');
            loadNetworks();
            setupInfiniteScroll();
        });
        
        // Selection functions
        function toggleSelectAll() {
            const selectAll = document.getElementById('select-all-checkbox');
            const checkboxes = document.querySelectorAll('.network-checkbox');
            checkboxes.forEach(cb => cb.checked = selectAll.checked);
            updateSelectionCount();
        }
        
        function updateSelectionCount() {
            const checked = document.querySelectorAll('.network-checkbox:checked').length;
            const countSpan = document.getElementById('selected-count');
            const mapBtn = document.getElementById('show-on-map-btn');
            if (countSpan) countSpan.textContent = checked;
            if (mapBtn) mapBtn.style.display = checked > 0 ? 'inline-block' : 'none';
        }
        
        function showSelectedOnMap() {
            const selected = Array.from(document.querySelectorAll('.network-checkbox:checked'))
                .map(cb => cb.dataset.bssid);
            if (selected.length === 0) return;
            
            // Store selected BSSIDs in sessionStorage
            sessionStorage.setItem('selectedNetworks', JSON.stringify(selected));
            
            // Navigate to geospatial page
            window.location.href = '/geospatial.html?selected=' + encodeURIComponent(selected.join(','));
        }
    </script>
    
    
    <script src="/assets/js/base-components.js"></script>
</body>
</html>