<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>ShadowCheck - Advanced Visualization</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <script src="https://cdn.jsdelivr.net/npm/deck.gl@8.9.0/dist.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@deck.gl/extensions@8.9.0/dist.min.js"></script>
    <script src="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v2.15.0/mapbox-gl.css" rel="stylesheet" />
    <style>
        body { margin: 0; font-family: Arial, sans-serif; }
        #map { width: 100vw; height: 100vh; }
        .controls {
            position: absolute; top: 10px; left: 10px; z-index: 1000;
            background: rgba(0,0,0,0.8); color: white; padding: 15px; border-radius: 8px;
            max-width: 300px;
        }
        .control-group { margin-bottom: 10px; }
        label { display: block; margin-bottom: 5px; font-size: 12px; }
        input[type="range"] { width: 100%; }
        select { width: 100%; padding: 5px; }
        .loading {
            position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 8px; z-index: 9999;
        }
    </style>
</head>
<body>
    <div id="loading" class="loading">Loading network data...</div>
    <div id="map"></div>
    <div class="controls">
        <h3>üõ°Ô∏è ShadowCheck Networks</h3>
        <div class="control-group">
            <label>Dataset:</label>
            <select id="datasetType">
                <option value="networks">Networks (117K trilaterated)</option>
                <option value="observations">Observations (416K raw)</option>
            </select>
        </div>
        <div class="control-group">
            <label>3D View - Pitch: <span id="pitchValue">0¬∞</span></label>
            <input type="range" id="pitch" min="0" max="60" value="0" onchange="update3D()">
        </div>
        <div class="control-group">
            <label>3D Height: <span id="heightValue">1</span></label>
            <input type="range" id="height3d" min="1" max="50" value="1" onchange="update3D()">
        </div>
        <div class="control-group">
            <label>Visualization Type:</label>
            <select id="layerType" onchange="updateVisualization()">
                <option value="scatterplot">Points</option>
                <option value="heatmap">Heatmap</option>
                <option value="hexagon">Hexagon Clusters</option>
            </select>
        </div>
        <div class="control-group">
            <label>Point Size: <span id="sizeValue">2</span></label>
            <input type="range" id="pointSize" min="0.5" max="20" step="0.5" value="2" onchange="updateVisualization()">
        </div>
        <div class="control-group">
            <label>Drawing Mode:</label>
            <select id="drawMode" onchange="toggleDrawing()">
                <option value="none">None</option>
                <option value="rectangle">Rectangle Select</option>
                <option value="polygon">Polygon Select</option>
                <option value="circle">Circle Select</option>
            </select>
        </div>
        <div class="control-group">
            <button onclick="clearSelection()" style="width: 100%; padding: 5px; background: #ff4444; color: white; border: none; border-radius: 3px;">Clear Selection</button>
        </div>
        
        <div id="drawingPanel" style="position: absolute; top: 20px; right: 20px; background: rgba(15, 23, 42, 0.9); padding: 12px; border-radius: 8px; border: 1px solid rgba(148, 163, 184, 0.2); color: white; z-index: 100; font-size: 12px; display: none;">
            <div style="margin-bottom: 8px; font-weight: bold;">Drawing Mode Active</div>
            <div id="drawingInstructions" style="margin-bottom: 8px; color: #22d3ee;"></div>
            <button onclick="cancelPolygon()" style="width: 100%; padding: 6px; background: #ef4444; color: white; border: none; border-radius: 4px; cursor: pointer;">Cancel</button>
        </div>
        
        <div class="control-group">
            <label>Signal Threshold: <span id="thresholdValue">-100</span> dBm</label>
            <input type="range" id="signalThreshold" min="-100" max="-30" value="-100" onchange="updateVisualization()">
        </div>
        <div id="stats" style="font-size: 11px; margin-top: 10px;"></div>
    </div>
    
    <script>
        let deckgl, mapboxToken, networkData = [];
        let selectedPoints = [];
        let drawStart = null;
        let polygonPoints = [];
        let isDrawing = false;
        let drawingMode = null;
        
        async function init() {
            try {
                const [tokenRes, dataRes] = await Promise.all([
                    fetch('/api/mapbox-token'),
                    fetch('/api/kepler/data')
                ]);
                
                const tokenData = await tokenRes.json();
                const geojson = await dataRes.json();
                
                if (geojson.error) throw new Error(`API Error: ${geojson.error}`);
                if (!geojson.features || !Array.isArray(geojson.features)) throw new Error(`Invalid data format`);
                if (geojson.features.length === 0) throw new Error('No network data found');
                
                mapboxToken = tokenData.token;
                networkData = geojson.features.map(f => ({
                    position: [f.geometry.coordinates[0], f.geometry.coordinates[1]],
                    bssid: f.properties.bssid,
                    ssid: f.properties.ssid,
                    signal: f.properties.max_signal || 0,
                    level: f.properties.bestlevel || 0,
                    encryption: f.properties.encryption,
                    channel: f.properties.channel,
                    frequency: f.properties.frequency,
                    manufacturer: f.properties.manufacturer,
                    device_type: f.properties.device_type,
                    type: f.properties.type,
                    capabilities: f.properties.capabilities,
                    timestamp: f.properties.first_seen,
                    last_seen: f.properties.last_seen
                }));
                
                console.log(`Loaded ${networkData.length} networks`);
                
                deckgl = new deck.DeckGL({
                    container: 'map',
                    mapboxApiAccessToken: mapboxToken,
                    mapStyle: 'mapbox://styles/mapbox/dark-v11',
                    initialViewState: {
                        longitude: -83.6968,
                        latitude: 43.0234,
                        zoom: 10,
                        pitch: 0,
                        bearing: 0,
                        minZoom: 1,
                        maxZoom: 24
                    },
                    controller: true,
                    getTooltip: ({object}) => object && {
                        html: generateSmartTooltip(object),
                        style: { backgroundColor: 'transparent', fontSize: '12px' }
                    },
                    onClick: ({object}) => {
                        if (object && !selectedPoints.find(p => p.bssid === object.bssid)) {
                            selectedPoints.push(object);
                            updateStats();
                        }
                    }
                });
                
                updateVisualization();
                updateStats();
                document.getElementById('loading').style.display = 'none';
            } catch (error) {
                console.error('Error:', error);
                document.getElementById('loading').innerHTML = 'Error: ' + error.message;
            }
        }
        
        function updateVisualization() {
            const layerType = document.getElementById('layerType').value;
            const pointSize = parseInt(document.getElementById('pointSize').value);
            const threshold = parseInt(document.getElementById('signalThreshold').value);
            
            document.getElementById('sizeValue').textContent = pointSize;
            document.getElementById('thresholdValue').textContent = threshold + ' dBm';
            
            const filteredData = networkData.filter(d => d.signal >= threshold);
            let layer;
            
            if (layerType === 'scatterplot') {
                layer = new deck.ScatterplotLayer({
                    id: 'networks',
                    data: filteredData,
                    getPosition: d => d.position,
                    getRadius: pointSize * 10,
                    getFillColor: d => {
                        if (d.signal > -50) return [255, 0, 0, 180];
                        if (d.signal > -70) return [255, 255, 0, 180];
                        return [0, 255, 0, 180];
                    },
                    pickable: true,
                    radiusMinPixels: 2,
                    radiusMaxPixels: 50
                });
            } else if (layerType === 'heatmap') {
                layer = new deck.HeatmapLayer({
                    id: 'networks-heatmap',
                    data: filteredData,
                    getPosition: d => d.position,
                    getWeight: d => Math.max(1, d.signal / 10),
                    radiusPixels: 50
                });
            } else if (layerType === 'hexagon') {
                layer = new deck.HexagonLayer({
                    id: 'networks-hexagon',
                    data: filteredData,
                    getPosition: d => d.position,
                    radius: 200,
                    elevationScale: 4,
                    extruded: true,
                    pickable: true,
                    getFillColor: [255, 140, 0, 180]
                });
            }
            
            deckgl.setProps({ layers: [layer] });
            updateStats(filteredData.length);
        }
        
        function updateStats(filtered = networkData.length) {
            const selectedCount = selectedPoints.length;
            document.getElementById('stats').innerHTML = `
                üìä ${filtered.toLocaleString()} / ${networkData.length.toLocaleString()} networks<br>
                üî• FULL DATASET - GPU BEAST MODE<br>
                üéØ Selected: ${selectedCount} networks<br>
                üìç Interactive tooltips & selection<br>
                ‚ö° WebGL performance at scale
            `;
        }
        
        function update3D() {
            const pitch = parseInt(document.getElementById('pitch').value);
            const height = parseInt(document.getElementById('height3d').value);
            
            document.getElementById('pitchValue').textContent = pitch + '¬∞';
            document.getElementById('heightValue').textContent = height;
            
            deckgl.setProps({
                initialViewState: {
                    longitude: -83.6968,
                    latitude: 43.0234,
                    zoom: 10,
                    pitch: pitch,
                    bearing: 0
                }
            });
            
            updateVisualization();
        }
        
        function toggleDrawing() {
            const mode = document.getElementById('drawMode').value;
            
            if (mode === 'none') {
                deckgl.setProps({ controller: true, getCursor: () => 'grab' });
                resetDrawingState();
            } else if (mode === 'rectangle') {
                deckgl.setProps({ controller: false, getCursor: () => 'crosshair' });
                enableRectangleSelection();
            } else if (mode === 'polygon') {
                deckgl.setProps({ controller: false, getCursor: () => 'crosshair' });
                enablePolygonSelection();
            } else if (mode === 'circle') {
                deckgl.setProps({ controller: false, getCursor: () => 'crosshair' });
                enableCircleSelection();
            }
        }
        
        function resetDrawingState() {
            const canvas = deckgl.canvas;
            canvas.onmousedown = null;
            canvas.onmouseup = null;
            canvas.oncontextmenu = null;
            document.onkeydown = null;
            canvas.style.cursor = 'grab';
            document.getElementById('drawingPanel').style.display = 'none';
            
            const currentLayers = deckgl.props.layers.filter(l => 
                !l.id.includes('polygon') && !l.id.includes('circle')
            );
            deckgl.setProps({ layers: currentLayers });
        }
        
        function enableCircleSelection() {
            const canvas = deckgl.canvas;
            let circleCenter = null;
            
            document.getElementById('drawingPanel').style.display = 'block';
            document.getElementById('drawingInstructions').innerHTML = `
                <strong>‚≠ï Circle Mode:</strong><br>
                üñ±Ô∏è Click center, drag radius<br>
                üîí Release to finish<br>
                ‚åõ ESC to cancel
            `;
            
            canvas.onmousedown = (e) => {
                const rect = canvas.getBoundingClientRect();
                const screenPoint = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
                
                const viewport = deckgl.getViewports()[0];
                circleCenter = viewport.unproject([screenPoint.x, screenPoint.y]);
                isDrawing = true;
            };
            
            canvas.onmousemove = (e) => {
                if (isDrawing && circleCenter) {
                    const rect = canvas.getBoundingClientRect();
                    const screenPoint = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const viewport = deckgl.getViewports()[0];
                    const currentPoint = viewport.unproject([screenPoint.x, screenPoint.y]);
                    
                    const radius = getDistance(circleCenter, currentPoint);
                    updateCirclePreview(circleCenter, radius);
                }
            };
            
            canvas.onmouseup = (e) => {
                if (isDrawing && circleCenter) {
                    const rect = canvas.getBoundingClientRect();
                    const screenPoint = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const viewport = deckgl.getViewports()[0];
                    const endPoint = viewport.unproject([screenPoint.x, screenPoint.y]);
                    const radius = getDistance(circleCenter, endPoint);
                    
                    selectNetworksInCircle(circleCenter, radius);
                }
                isDrawing = false;
                circleCenter = null;
            };
            
            document.onkeydown = (e) => {
                if (e.key === 'Escape') cancelDrawing();
            };
        }
        
        function getDistance(point1, point2) {
            const [lng1, lat1] = point1;
            const [lng2, lat2] = point2;
            const R = 6371000; // Earth radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLng = (lng2 - lng1) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                    Math.sin(dLng/2) * Math.sin(dLng/2);
            return 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)) * R;
        }
        
        function updateCirclePreview(center, radius) {
            const points = [];
            for (let i = 0; i <= 64; i++) {
                const angle = (i / 64) * 2 * Math.PI;
                const lat = center[1] + (radius / 111320) * Math.cos(angle);
                const lng = center[0] + (radius / (111320 * Math.cos(center[1] * Math.PI / 180))) * Math.sin(angle);
                points.push([lng, lat]);
            }
            
            const circleLayer = new deck.PathLayer({
                id: 'circle-preview',
                data: [{ path: points }],
                getPath: d => d.path,
                getColor: [34, 211, 238, 255],
                getWidth: 3,
                widthMinPixels: 2,
                pickable: false
            });
            
            const centerLayer = new deck.ScatterplotLayer({
                id: 'circle-center',
                data: [{ position: center }],
                getPosition: d => d.position,
                getRadius: 8,
                getFillColor: [34, 211, 238, 200],
                pickable: false,
                radiusMinPixels: 5
            });
            
            const currentLayers = deckgl.props.layers.filter(l => 
                l.id !== 'circle-preview' && l.id !== 'circle-center'
            );
            
            deckgl.setProps({ layers: [...currentLayers, circleLayer, centerLayer] });
        }
        
        function selectNetworksInCircle(center, radius) {
            const selected = networkData.filter(network => {
                const distance = getDistance(center, network.position);
                return distance <= radius;
            });
            
            selectedPoints = selected;
            console.log(`‚úì Selected ${selected.length} networks in circle`);
            document.getElementById('drawingInstructions').innerHTML = `‚úì Selected ${selected.length} networks!`;
            
            setTimeout(() => cancelDrawing(), 1500);
            updateStats();
        }
        
        function cancelDrawing() {
            document.getElementById('drawMode').value = 'none';
            deckgl.setProps({ controller: true });
            resetDrawingState();
            polygonPoints = [];
            isDrawing = false;
            drawingMode = null;
        }
        
        function enableRectangleSelection() {
            const canvas = deckgl.canvas;
            
            canvas.onmousedown = (e) => {
                isDrawing = true;
                const rect = canvas.getBoundingClientRect();
                drawStart = {
                    x: e.clientX - rect.left,
                    y: e.clientY - rect.top
                };
            };
            
            canvas.onmouseup = (e) => {
                if (isDrawing && drawStart) {
                    const rect = canvas.getBoundingClientRect();
                    const drawEnd = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const viewport = deckgl.getViewports()[0];
                    const startGeo = viewport.unproject([drawStart.x, drawStart.y]);
                    const endGeo = viewport.unproject([drawEnd.x, drawEnd.y]);
                    
                    selectNetworksInBounds(startGeo, endGeo);
                }
                isDrawing = false;
                drawStart = null;
            };
        }
        
        function enablePolygonSelection() {
            const canvas = deckgl.canvas;
            polygonPoints = [];
            isDrawing = true;
            drawingMode = 'polygon';
            
            document.getElementById('drawingPanel').style.display = 'block';
            document.getElementById('drawingInstructions').innerHTML = `
                <strong>üî∑ Polygon Mode:</strong><br>
                üñ±Ô∏è Left-click to add points<br>
                üîí Right-click to finish<br>
                ‚åõ ESC to cancel
            `;
            
            canvas.style.cursor = 'crosshair';
            
            canvas.onmousedown = (e) => {
                if (e.button === 0) {
                    const rect = canvas.getBoundingClientRect();
                    const screenPoint = {
                        x: e.clientX - rect.left,
                        y: e.clientY - rect.top
                    };
                    
                    const viewports = deckgl.getViewports();
                    if (!viewports || !viewports[0]) return;
                    
                    const viewport = viewports[0];
                    const geoPoint = viewport.unproject([screenPoint.x, screenPoint.y]);
                    
                    polygonPoints.push(geoPoint);
                    console.log(`‚úì Point ${polygonPoints.length}: [${geoPoint[0].toFixed(4)}, ${geoPoint[1].toFixed(4)}]`);
                    updatePolygonPreview();
                    
                } else if (e.button === 2) {
                    e.preventDefault();
                    finishPolygon();
                }
            };
            
            canvas.oncontextmenu = (e) => e.preventDefault();
            document.onkeydown = (e) => {
                if (e.key === 'Escape') cancelPolygon();
            };
        }
        
        function updatePolygonPreview() {
            if (polygonPoints.length === 0) return;
            
            const pointLayer = new deck.ScatterplotLayer({
                id: 'polygon-points',
                data: polygonPoints.map((p, i) => ({ position: p, index: i })),
                getPosition: d => d.position,
                getRadius: 8,
                getFillColor: [34, 211, 238, 200],
                pickable: false,
                radiusMinPixels: 5
            });
            
            let lineLayer = null;
            if (polygonPoints.length > 1) {
                const lineCoords = [...polygonPoints];
                if (polygonPoints.length >= 3) lineCoords.push(polygonPoints[0]);
                
                lineLayer = new deck.PathLayer({
                    id: 'polygon-preview',
                    data: [{ path: lineCoords }],
                    getPath: d => d.path,
                    getColor: [34, 211, 238, 255],
                    getWidth: 3,
                    widthMinPixels: 2,
                    pickable: false
                });
            }
            
            const currentLayers = deckgl.props.layers.filter(l => 
                l.id !== 'polygon-points' && l.id !== 'polygon-preview'
            );
            
            const newLayers = [...currentLayers, pointLayer];
            if (lineLayer) newLayers.push(lineLayer);
            
            deckgl.setProps({ layers: newLayers });
        }
        
        function finishPolygon() {
            if (polygonPoints.length < 3) {
                document.getElementById('drawingInstructions').innerHTML = '‚ùå Need at least 3 points!';
                return;
            }
            
            const selected = networkData.filter(network => 
                isPointInPolygon(network.position, polygonPoints)
            );
            
            selectedPoints = selected;
            console.log(`‚úì Selected ${selected.length} networks`);
            document.getElementById('drawingInstructions').innerHTML = `‚úì Selected ${selected.length} networks!`;
            
            setTimeout(() => cancelPolygon(), 1500);
            updateStats();
        }
        
        function cancelPolygon() {
            cancelDrawing();
        }
        
        function isPointInPolygon(point, polygon) {
            const [x, y] = point;
            let inside = false;
            
            for (let i = 0, j = polygon.length - 1; i < polygon.length; j = i++) {
                const [xi, yi] = polygon[i];
                const [xj, yj] = polygon[j];
                
                if (((yi > y) !== (yj > y)) && (x < (xj - xi) * (y - yi) / (yj - yi) + xi)) {
                    inside = !inside;
                }
            }
            return inside;
        }
        
        function selectNetworksInBounds(startGeo, endGeo) {
            const minLng = Math.min(startGeo[0], endGeo[0]);
            const maxLng = Math.max(startGeo[0], endGeo[0]);
            const minLat = Math.min(startGeo[1], endGeo[1]);
            const maxLat = Math.max(startGeo[1], endGeo[1]);
            
            const selected = networkData.filter(network => {
                const [lng, lat] = network.position;
                return lng >= minLng && lng <= maxLng && lat >= minLat && lat <= maxLat;
            });
            
            selectedPoints = selected;
            console.log(`Selected ${selected.length} networks in rectangle`);
            updateStats();
            
            document.getElementById('drawMode').value = 'none';
            toggleDrawing();
        }
        
        function clearSelection() {
            selectedPoints = [];
            updateStats();
        }
        
        function generateSmartTooltip(network) {
            const radioType = interpretWigleType(network.type);
            const security = interpretSecurity(network.capabilities, network.encryption);
            const signalStrength = interpretSignalStrength(network.signal);
            const networkIcon = getNetworkIcon(network.type);
            
            return `
                <div style="background: rgba(15, 23, 42, 0.95); color: #f8fafc; padding: 15px; border-radius: 8px; max-width: 380px; font-size: 11px; border: 1px solid rgba(148, 163, 184, 0.2);">
                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 12px;">
                        ${networkIcon}
                        <span style="color: #22d3ee; font-weight: bold; font-size: 15px;">${network.ssid}</span>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 12px;">
                        <div><span style="color: #94a3b8; font-size: 10px;">BSSID</span><br><span style="font-family: monospace; font-size: 10px;">${network.bssid}</span></div>
                        <div><span style="color: #94a3b8; font-size: 10px;">Signal</span><br><span style="color: ${signalStrength.color};">${network.signal} dBm (${signalStrength.text})</span></div>
                        <div><span style="color: #94a3b8; font-size: 10px;">Channel</span><br>${network.channel}</div>
                        <div><span style="color: #94a3b8; font-size: 10px;">Frequency</span><br>${network.frequency} MHz</div>
                        <div><span style="color: #94a3b8; font-size: 10px;">Security</span><br><span style="color: ${security.color};">${security.text}</span></div>
                        <div><span style="color: #94a3b8; font-size: 10px;">Level</span><br>${network.level}</div>
                    </div>
                    
                    <div style="border-top: 1px solid rgba(148, 163, 184, 0.2); padding-top: 8px; margin-bottom: 8px;">
                        <div style="margin-bottom: 6px;"><span style="color: #94a3b8;">Radio Type:</span> <span style="color: #22d3ee;">${radioType.name}</span> <span style="color: #64748b; font-size: 10px;">(${radioType.code})</span></div>
                        ${network.manufacturer !== 'Unknown' ? `<div style="margin-bottom: 6px;"><span style="color: #94a3b8;">Manufacturer:</span> ${network.manufacturer}</div>` : ''}
                        ${network.device_type !== 'Unknown' ? `<div style="margin-bottom: 6px;"><span style="color: #94a3b8;">Device Type:</span> ${network.device_type}</div>` : ''}
                        ${network.capabilities !== 'Unknown' ? `<div style="margin-bottom: 6px;"><span style="color: #94a3b8;">Capabilities:</span> <span style="font-family: monospace; font-size: 10px;">${network.capabilities}</span></div>` : ''}
                    </div>
                    
                    <div style="border-top: 1px solid rgba(148, 163, 184, 0.2); padding-top: 8px;">
                        <div style="margin-bottom: 4px;"><span style="color: #94a3b8;">Coordinates:</span> <span style="font-family: monospace; font-size: 10px;">${network.position[1].toFixed(6)}, ${network.position[0].toFixed(6)}</span></div>
                        ${network.timestamp ? `<div style="margin-bottom: 4px;"><span style="color: #94a3b8;">First Seen:</span> <span style="color: #e2e8f0;">${new Date(network.timestamp).toLocaleString()}</span></div>` : ''}
                        ${network.last_seen ? `<div style="margin-bottom: 4px;"><span style="color: #94a3b8;">Last Seen:</span> <span style="color: #e2e8f0;">${new Date(network.last_seen).toLocaleString()}</span></div>` : ''}
                        ${network.timestamp ? `<div><span style="color: #94a3b8;">Seen:</span> <span style="color: #fbbf24; font-weight: bold;">${new Date(network.timestamp).toLocaleString()}</span></div>` : ''}
                    </div>
                </div>
            `;
        }
        
        function interpretWigleType(type) {
            const typeMap = {'W': 'WiFi', 'E': 'BLE', 'B': 'Bluetooth', 'L': 'LTE', 'N': '5G NR', 'G': 'GSM'};
            if (!type || type === 'Unknown' || type === '') return { name: 'WiFi', code: 'W' };
            const typeCode = type.toString().toUpperCase();
            return { name: typeMap[typeCode] || typeCode || 'Unknown', code: typeCode };
        }
        
        function interpretSecurity(capabilities, encryption) {
            if (!capabilities || capabilities === 'Unknown') {
                if (encryption && encryption !== 'Open/Unknown') return { text: encryption, color: '#fbbf24' };
                return { text: 'Open', color: '#ef4444' };
            }
            if (capabilities.includes('WPA3')) return { text: 'WPA3 (Secure)', color: '#22c55e' };
            if (capabilities.includes('WPA2')) return { text: 'WPA2 (Secure)', color: '#22c55e' };
            if (capabilities.includes('WPA')) return { text: 'WPA (Weak)', color: '#f59e0b' };
            if (capabilities.includes('WEP')) return { text: 'WEP (Insecure)', color: '#ef4444' };
            return { text: 'Open', color: '#ef4444' };
        }
        
        function interpretSignalStrength(signal) {
            if (signal > -50) return { color: '#22c55e', text: 'Strong' };
            if (signal > -70) return { color: '#fbbf24', text: 'Medium' };
            return { color: '#ef4444', text: 'Weak' };
        }
        
        function getNetworkIcon(networkType) {
            const type = (networkType || 'wifi').toLowerCase();
            if (type.includes('ble') || type.includes('bluetooth') || type === 'b' || type === 'e') {
                return `<svg viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16"><path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z"/></svg>`;
            }
            if (type.includes('cellular') || type.includes('cell') || type.includes('gsm') || type.includes('lte') || type.includes('5g') || type === 'g' || type === 'l' || type === 'n') {
                return `<svg viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16"><path d="M17.77 3.77L16 2 6 12l10 10 1.77-1.77L9.54 12z"/><path d="M6 12l10-10 1.77 1.77L9.54 12l8.23 8.23L16 22z"/><path d="M6 12l5-5v10z"/></svg>`;
            }
            return `<svg viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16"><path d="M12 18.5a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3z"/><path d="M12 14c-1.7 0-3.3.6-4.6 1.8a1 1 0 1 0 1.4 1.4A5 5 0 0 1 12 16a5 5 0 0 1 3.2 1.2 1 1 0 1 0 1.3-1.5A6.9 6.9 0 0 0 12 14z"/><path d="M12 9.5c-3 0-5.8 1.1-8 3.2a1 1 0 1 0 1.4 1.4c1.8-1.8 4.1-2.7 6.6-2.7 2.5 0 4.8.9 6.6 2.7a1 1 0 1 0 1.4-1.4c-2.2-2.1-5.1-3.2-8-3.2z"/><path d="M12 5c-4.3 0-8.3 1.6-11.3 4.6a1 1 0 1 0 1.4 1.4C4.6 7.5 8.2 6 12 6s7.4 1.5 9.9 4a1 1 0 1 0 1.4-1.4C20.3 6.6 16.3 5 12 5z"/></svg>`;
        }
        
        init();
    </script>
</body>
</html>
