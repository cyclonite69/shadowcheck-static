<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowCheck - Geospatial Intelligence</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
            color: #f8fafc;
            height: 100vh;
            overflow: hidden;
        }

        .container {
            display: flex;
            height: 100vh;
            flex-direction: column;
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 20px;
            background: rgba(30, 41, 59, 0.8);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            gap: 20px;
            flex-shrink: 0;
            z-index: 100;
        }

        .header-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo {
            width: 32px;
            height: 32px;
            background: linear-gradient(135deg, #3b82f6, #8b5cf6);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 16px;
        }

        .header-title {
            font-size: 14px;
            font-weight: 600;
        }

        .nav-links {
            display: flex;
            gap: 8px;
            justify-content: center;
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
        }

        .header-right-group {
            display: flex;
            align-items: center;
            gap: 12px;
            flex: 1;
            justify-content: flex-end;
        }

        .nav-link {
            border: none;
            background: rgba(59, 130, 246, 0.1);
            color: #e0e7ff;
            padding: 8px 16px;
            border-radius: 6px;
            font-size: 12px;
            transition: all 0.2s;
            border: 1px solid rgba(148, 163, 184, 0.2);
            text-decoration: none;
            display: inline-block;
        }

        .nav-link:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(148, 163, 184, 0.4);
        }

        .nav-link.active {
            background: rgba(59, 130, 246, 0.3);
            border-color: #3b82f6;
        }

        .status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 12px;
            color: #cbd5e1;
        }

        .status-dot {
            width: 6px;
            height: 6px;
            background: #10b981;
            border-radius: 50%;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        @keyframes flash {
            0%, 100% { transform: scale(1); opacity: 1; }
            50% { transform: scale(1.1); opacity: 0.7; }
        }

        .main {
            display: grid;
            gap: 12px;
            padding: 12px;
            flex: 1;
            overflow: hidden;
            transition: grid-template-columns 0.3s ease, grid-template-rows 0.3s ease;
        }

        /* Layout modes */
        .main.layout-side-by-side {
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .main.layout-side-by-side #map-panel {
            grid-column: 1;
            grid-row: 1 / 3;
        }

        .main.layout-side-by-side #threats-panel {
            grid-column: 2;
            grid-row: 1;
        }

        .main.layout-side-by-side #networks-panel {
            grid-column: 2;
            grid-row: 2;
        }

        .main.layout-vertical {
            grid-template-columns: 1fr;
            grid-template-rows: 1fr 1fr 1fr;
        }

        .main.layout-vertical #map-panel {
            grid-column: 1;
            grid-row: 1;
        }

        .main.layout-vertical #threats-panel {
            grid-column: 1;
            grid-row: 2;
        }

        .main.layout-vertical #networks-panel {
            grid-column: 1;
            grid-row: 3;
        }

        .main.layout-map-focus {
            grid-template-columns: 2fr 1fr;
            grid-template-rows: 1fr 1fr;
        }

        .main.layout-map-focus #map-panel {
            grid-column: 1;
            grid-row: 1 / 3;
        }

        .main.layout-map-focus #threats-panel {
            grid-column: 2;
            grid-row: 1;
        }

        .main.layout-map-focus #networks-panel {
            grid-column: 2;
            grid-row: 2;
        }

        .layout-toggle {
            display: flex;
            gap: 4px;
            background: rgba(30, 41, 59, 0.6);
            padding: 4px;
            border-radius: 6px;
            border: 1px solid rgba(148, 163, 184, 0.2);
        }

        .layout-toggle button {
            padding: 4px 8px;
            font-size: 11px;
            background: transparent;
            border: none;
        }

        .layout-toggle button.active {
            background: rgba(59, 130, 246, 0.3);
            border: 1px solid #3b82f6;
        }

        .panel {
            background: rgba(30, 41, 59, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.1);
            border-radius: 12px;
            display: flex;
            flex-direction: column;
            overflow: auto;
            resize: both;
            min-width: 200px;
            min-height: 150px;
        }

        .panel-header {
            padding: 12px 16px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
            font-size: 13px;
            font-weight: 600;
            color: #cbd5e1;
            flex-shrink: 0;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .panel-content {
            flex: 1;
            overflow-y: auto;
            padding: 12px 16px;
        }

        #map-panel {
            grid-column: 1 / 3;
            grid-row: 1;
        }

        #map-panel .panel-content {
            padding: 0;
            display: flex;
            flex-direction: column;
        }

        #map {
            width: 100%;
            height: 100%;
            flex: 1;
            min-height: 400px;
        }

        #threats-panel {
            grid-column: 1;
            grid-row: 2;
        }

        #networks-panel {
            grid-column: 2;
            grid-row: 2;
        }

        select {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: #e0e7ff;
            padding: 6px 10px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
        }

        button {
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: #e0e7ff;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 12px;
            cursor: pointer;
            transition: all 0.2s;
        }

        button:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(148, 163, 184, 0.4);
        }

        .threat-list {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .threat-row {
            background: rgba(239, 68, 68, 0.05);
            border: 1px solid rgba(239, 68, 68, 0.3);
            border-left: 3px solid #ef4444;
            border-radius: 6px;
            padding: 8px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 10px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            gap: 8px;
        }

        .threat-row:hover {
            background: rgba(239, 68, 68, 0.15);
        }

        /* Severity level colors */
        .threat-row.severity-critical {
            background: rgba(239, 68, 68, 0.1);
            border-color: rgba(239, 68, 68, 0.4);
            border-left-color: #dc2626;
        }

        .threat-row.severity-critical:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .threat-row.severity-high {
            background: rgba(251, 146, 60, 0.1);
            border-color: rgba(251, 146, 60, 0.4);
            border-left-color: #ea580c;
        }

        .threat-row.severity-high:hover {
            background: rgba(251, 146, 60, 0.2);
        }

        .threat-row.severity-medium {
            background: rgba(234, 179, 8, 0.1);
            border-color: rgba(234, 179, 8, 0.4);
            border-left-color: #ca8a04;
        }

        .threat-row.severity-medium:hover {
            background: rgba(234, 179, 8, 0.2);
        }

        .threat-row.severity-low {
            background: rgba(59, 130, 246, 0.1);
            border-color: rgba(59, 130, 246, 0.4);
            border-left-color: #2563eb;
        }

        .threat-row.severity-low:hover {
            background: rgba(59, 130, 246, 0.2);
        }

        .threat-score {
            background: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            padding: 2px 6px;
            border-radius: 4px;
            font-weight: 600;
            font-size: 10px;
            white-space: nowrap;
        }

        .threat-score.severity-critical {
            background: rgba(239, 68, 68, 0.3);
            color: #fca5a5;
        }

        .threat-score.severity-high {
            background: rgba(251, 146, 60, 0.3);
            color: #fdba74;
        }

        .threat-score.severity-medium {
            background: rgba(234, 179, 8, 0.3);
            color: #fde047;
        }

        .threat-score.severity-low {
            background: rgba(59, 130, 246, 0.3);
            color: #93c5fd;
        }

        .network-table {
            width: 100%;
            font-size: 11px;
            border-collapse: collapse;
        }

        .network-table thead {
            position: sticky;
            top: 0;
            background: rgba(30, 41, 59, 0.9);
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }

        .network-table th {
            padding: 8px;
            text-align: left;
            color: #94a3b8;
            font-weight: 500;
        }

        .network-table td {
            padding: 8px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.1);
        }

        .network-table tr:hover {
            background: rgba(59, 130, 246, 0.05);
        }

        .loading {
            display: flex;
            align-items: center;
            justify-content: center;
            color: #94a3b8;
            font-size: 12px;
            padding: 20px;
        }

        ::-webkit-scrollbar {
            width: 6px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(148, 163, 184, 0.3);
            border-radius: 3px;
        }

        /* Dark Tooltip Styling - from shadowcheck */
        .dark-tooltip-popup .mapboxgl-popup-content {
            background: rgb(18, 18, 18) !important;  /* Fully opaque - no transparency */
            opacity: 1 !important;  /* Force full opacity */
            border: 1px solid rgba(255, 255, 255, 0.1) !important;
            border-radius: 14px !important;
            padding: 10px 12px !important;
            box-shadow: 0 8px 28px rgba(0, 0, 0, 0.5) !important;
            z-index: 10000 !important;  /* Ensure tooltip appears above all map elements */
        }

        /* Ensure popup tip (arrow) is visible for dark tooltips */
        .dark-tooltip-popup .mapboxgl-popup-tip {
            border-top-color: rgb(18, 18, 18) !important;
            border-bottom-color: rgb(18, 18, 18) !important;
        }

        .dark-tooltip-popup .mapboxgl-popup-close-button {
            color: #fff !important;
            font-size: 20px !important;
            padding: 0 6px !important;
            right: 4px !important;
            top: 4px !important;
        }

        .dark-tooltip-popup .mapboxgl-popup-close-button:hover {
            background: rgba(255, 255, 255, 0.1) !important;
            border-radius: 4px !important;
        }

        .dark-tooltip {
            color: #fff;
            line-height: 1.3;
            max-width: 300px;
            min-width: 220px;
        }

        .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }

        .tooltip-ssid {
            font-size: 13px;
            font-weight: 600;
            color: #fff;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 180px;
        }

        .tooltip-icon {
            flex-shrink: 0;
            margin-left: 8px;
        }

        .tooltip-field {
            display: flex;
            justify-content: space-between;
            align-items: baseline;
            margin-bottom: 3px;
            gap: 8px;
        }

        .observation-header {
            font-weight: 600;
            margin-bottom: 6px;
            padding-bottom: 4px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            color: #22d3ee;
        }

        .tooltip-label {
            color: #aaa;
            font-size: 11px;
            white-space: nowrap;
            min-width: 70px;
        }

        .tooltip-value {
            font-family: 'SF Mono', 'Consolas', 'Inconsolata', 'Roboto Mono', monospace;
            color: #e5e7eb;
            font-size: 11.5px;
            text-align: right;
            word-break: break-word;
        }

        .tooltip-value.mono {
            font-family: 'SF Mono', 'Consolas', 'Inconsolata', 'Roboto Mono', monospace;
        }

        .tooltip-timestamp {
            margin-top: 6px;
            padding-top: 4px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 11px;
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .signal-strong {
            color: #34d399 !important;
            font-weight: 600;
        }

        .signal-medium {
            color: #f59e0b !important;
            font-weight: 600;
        }

        .signal-weak {
            color: #ef4444 !important;
            font-weight: 600;
        }

        /* Advanced Network Table - Column Selector */
        .column-selector {
            position: relative;
            display: inline-block;
        }

        .column-selector-btn {
            padding: 6px 12px;
            font-size: 12px;
            background: rgba(59, 130, 246, 0.1);
            border: 1px solid rgba(148, 163, 184, 0.2);
            color: #e0e7ff;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .column-selector-btn:hover {
            background: rgba(59, 130, 246, 0.2);
            border-color: rgba(148, 163, 184, 0.4);
        }

        .column-selector-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            margin-top: 4px;
            background: rgba(30, 41, 59, 0.98);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.4);
            min-width: 200px;
            z-index: 1000;
            backdrop-filter: blur(10px);
        }

        .column-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
            font-size: 12px;
            font-weight: 600;
            color: #cbd5e1;
        }

        .column-selector-header .reset-btn {
            padding: 4px 8px;
            font-size: 11px;
            background: rgba(239, 68, 68, 0.1);
            border: 1px solid rgba(239, 68, 68, 0.3);
            color: #fca5a5;
            border-radius: 4px;
            cursor: pointer;
        }

        .column-selector-header .reset-btn:hover {
            background: rgba(239, 68, 68, 0.2);
        }

        .column-selector-list {
            max-height: 300px;
            overflow-y: auto;
            padding: 8px;
        }

        .column-selector-item {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 8px;
            cursor: pointer;
            border-radius: 4px;
            font-size: 12px;
            transition: background 0.2s;
        }

        .column-selector-item:hover {
            background: rgba(59, 130, 246, 0.1);
        }

        .column-selector-item input[type="checkbox"] {
            cursor: pointer;
        }

        .column-selector-item span {
            color: #e0e7ff;
        }

        /* Sortable Table Headers */
        .network-table th.sortable {
            cursor: pointer;
            user-select: none;
            position: relative;
            padding-right: 20px;
        }

        .network-table th.sortable:hover {
            background: rgba(59, 130, 246, 0.15);
        }

        .network-table th .sort-indicator {
            position: absolute;
            right: 6px;
            top: 50%;
            transform: translateY(-50%);
            font-size: 10px;
            color: #60a5fa;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .network-table th.sorted .sort-indicator {
            opacity: 1;
        }

        .network-table th.sortable:hover .sort-indicator {
            opacity: 0.5;
        }

        /* Network Table Enhancements */
        .network-table tbody tr {
            transition: background-color 0.2s;
        }

        .network-table tbody tr:nth-child(even) {
            background: rgba(30, 41, 59, 0.3);
        }

        .network-table tbody tr:hover {
            background: rgba(59, 130, 246, 0.1);
            cursor: pointer;
        }

        .network-table td.mono {
            font-family: 'SF Mono', 'Consolas', 'Monaco', 'Courier New', monospace;
        }

        .network-count-info {
            font-size: 11px;
            color: #94a3b8;
            margin-left: 8px;
        }
    </style>
</head>
<body>
    <div class="container">
        <!-- HEADER -->
        <div class="header">
            <div class="header-left">
                <div class="logo">SC</div>
                <div class="header-title">Geospatial Intelligence</div>
            </div>
            <div class="nav-links">
                <a href="/" class="nav-link" data-page="dashboard">Dashboard</a>
                <a href="/geospatial.html" class="nav-link active" data-page="geospatial">Geospatial</a>
                <a href="/analytics.html" class="nav-link" data-page="analytics">Analytics</a>
                <a href="/surveillance.html" class="nav-link" data-page="surveillance">Surveillance</a>
                <a href="/networks.html" class="nav-link" data-page="networks">Networks</a>
            </div>
            <div class="header-right-group">
                <div class="layout-toggle">
                    <button id="layout-side" class="active" title="Side by side">‚¨å Side</button>
                    <button id="layout-vertical" title="Vertical stack">‚¨ç Vertical</button>
                    <button id="layout-map" title="Map focus">‚¨å Map</button>
                </div>
                <div class="status">
                    <div class="status-dot"></div>
                    <span id="status-text">Online</span>
                </div>
                <button id="refresh-btn">üîÑ Refresh</button>
            </div>
        </div>

        <!-- MAIN GRID -->
        <div class="main layout-side-by-side" id="main-grid">
            <!-- MAP PANEL -->
            <div class="panel" id="map-panel">
                <div class="panel-header">
                    <span>üìç Network Distribution Map</span>
                    <div style="display: flex; gap: 8px;">
                        <select id="map-style-selector" onchange="changeMapStyle(this.value)">
                            <option value="night" selected>üåô Night</option>
                            <option value="dawn">üåÖ Dawn</option>
                            <option value="dusk">üåÜ Dusk</option>
                            <option value="day">‚òÄÔ∏è Day</option>
                            <option value="dark">üåë Dark</option>
                            <option value="satellite">üõ∞Ô∏è Satellite</option>
                        </select>
                        <button onclick="centerMapOnLocation()">üéØ Center</button>
                    </div>
                </div>
                <div class="panel-content">
                    <div id="map"></div>
                </div>
            </div>

            <!-- THREATS PANEL -->
            <div class="panel" id="threats-panel">
                <div class="panel-header">
                    <span>‚ö†Ô∏è Active Threats <span class="panel-count" id="threats-count">0</span></span>
                    <div style="display: flex; gap: 6px; flex: 1; max-width: 700px;">
                        <input type="text" id="threat-search" placeholder="Search threats..." style="flex: 1; min-width: 120px; padding: 4px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #e0e7ff; border-radius: 4px;">
                        <select id="threat-severity-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="all">All Severity</option>
                            <option value="critical">Critical (80+)</option>
                            <option value="high">High (70-79)</option>
                            <option value="medium">Medium (50-69)</option>
                            <option value="low">Low (30-49)</option>
                        </select>
                        <select id="threat-type-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="">All Types</option>
                            <option value="W">WiFi</option>
                            <option value="E">BLE</option>
                            <option value="B">Bluetooth</option>
                        </select>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="threat-list" id="threat-list">
                        <div class="loading">Loading threats...</div>
                    </div>
                </div>
            </div>

            <!-- NETWORKS PANEL -->
            <div class="panel" id="networks-panel">
                <div class="panel-header">
                    <span>üì° Recent Networks <span class="panel-count" id="networks-count">0</span></span>
                    <div style="display: flex; gap: 6px; flex: 1; max-width: 700px;">
                        <input type="text" id="network-search" placeholder="Search SSID/BSSID..." style="flex: 1; min-width: 120px; padding: 4px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #e0e7ff; border-radius: 4px;">
                        <select id="network-type-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="">All Types</option>
                            <option value="W">WiFi</option>
                            <option value="E">BLE</option>
                            <option value="B">Bluetooth</option>
                        </select>
                        <select id="network-security-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="">All Security</option>
                            <option value="OPEN">Open</option>
                            <option value="WEP">WEP</option>
                            <option value="WPA">WPA/WPA2</option>
                            <option value="WPA3">WPA3</option>
                        </select>
                    </div>
                </div>
                <div class="panel-content">
                    <table class="network-table" id="networks-table">
                        <thead>
                            <!-- Headers generated dynamically by renderNetworkTable() -->
                        </thead>
                        <tbody>
                            <tr>
                                <td colspan="4" class="loading">Loading networks...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // HTML escaping utility to prevent XSS
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Use dynamic API base URL based on current window location
        const API_BASE = Object.freeze(`${window.location.protocol}//${window.location.hostname}:3001/api`);
        let map = null;

        // Advanced Network Table Configuration
        const NETWORK_COLUMNS = {
            type: {
                label: 'Type',
                width: '60px',
                sortable: true,
                default: true,
                format: (val) => {
                    const typeMap = {
                        'W': 'WiFi',
                        'E': 'BLE',
                        'B': 'BT',
                        'L': 'LTE',
                        'N': '5G NR',
                        'G': 'GSM'
                    };
                    return typeMap[val] || 'WiFi';
                }
            },
            ssid: {
                label: 'SSID',
                width: '150px',
                sortable: true,
                default: true,
                format: (val) => val || '(hidden)'
            },
            bssid: {
                label: 'BSSID',
                width: '120px',
                sortable: true,
                default: true,
                monospace: true,
                format: (val) => val || 'N/A'
            },
            signal: {
                label: 'Signal (dBm)',
                width: '100px',
                sortable: true,
                default: true,
                format: (val) => val !== null && val !== undefined ? `${val} dBm` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : -999
            },
            security: {
                label: 'Security',
                width: '140px',
                sortable: true,
                default: true,
                format: (val) => val || 'Unknown'
            },
            frequency: {
                label: 'Frequency (GHz)',
                width: '120px',
                sortable: true,
                default: false,
                format: (val) => val ? `${val} GHz` : 'N/A',
                sortValue: (val) => val ? parseFloat(val) : 0
            },
            channel: {
                label: 'Channel',
                width: '80px',
                sortable: true,
                default: false,
                format: (val) => val || 'N/A'
            },
            observations: {
                label: 'Observations',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val || '1',
                sortValue: (val) => val ? parseInt(val) : 1
            },
            latitude: {
                label: 'Latitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            longitude: {
                label: 'Longitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            distanceFromHome: {
                label: 'Distance (km)',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(2)} km` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 999999
            },
            accuracy: {
                label: 'Accuracy (m)',
                width: '100px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(1)} m` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            timestamp: {
                label: 'Last Seen',
                width: '160px',
                sortable: true,
                default: true,
                format: (val) => {
                    if (!val) return 'Unknown';
                    try {
                        const date = typeof val === 'number' ? new Date(val) : new Date(val);
                        return date.toLocaleString();
                    } catch (e) {
                        return 'Unknown';
                    }
                },
                sortValue: (val) => {
                    if (!val) return 0;
                    return typeof val === 'number' ? val : new Date(val).getTime();
                }
            },
            misc: {
                label: 'Misc',
                width: '200px',
                sortable: false,
                default: false,
                format: (val) => val || ''
            }
        };

        // Network Table State Management
        class NetworkTableManager {
            constructor(pageId, abbreviatedMode = false) {
                this.pageId = pageId;
                this.abbreviatedMode = abbreviatedMode;
                this.storageKey = `networkListColumns-${pageId}`;
                this.networks = [];
                this.filteredNetworks = [];
                this.currentSort = { column: null, direction: null };
                this.visibleColumns = this.loadColumnPreferences();
                this.searchTerm = '';
                this.displayedCount = 0;
                this.batchSize = abbreviatedMode ? 20 : 50; // Smaller batch for abbreviated mode
            }

            // Load column visibility preferences from localStorage
            loadColumnPreferences() {
                const saved = localStorage.getItem(this.storageKey);
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading column preferences:', e);
                    }
                }
                // Return default columns
                return Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
            }

            // Save column visibility preferences to localStorage
            saveColumnPreferences() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.visibleColumns));
            }

            // Reset to default columns
            resetToDefaults() {
                this.visibleColumns = Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
                this.saveColumnPreferences();
            }

            // Toggle column visibility
            toggleColumn(columnKey) {
                const index = this.visibleColumns.indexOf(columnKey);
                if (index > -1) {
                    this.visibleColumns.splice(index, 1);
                } else {
                    this.visibleColumns.push(columnKey);
                }
                this.saveColumnPreferences();
            }

            // Set sort column
            setSort(column) {
                if (!NETWORK_COLUMNS[column] || !NETWORK_COLUMNS[column].sortable) return;

                if (this.currentSort.column === column) {
                    // Cycle through: asc -> desc -> null
                    if (this.currentSort.direction === 'asc') {
                        this.currentSort.direction = 'desc';
                    } else if (this.currentSort.direction === 'desc') {
                        this.currentSort = { column: null, direction: null };
                    }
                } else {
                    this.currentSort = { column, direction: 'asc' };
                }
            }

            // Apply search filter
            setSearch(term) {
                this.searchTerm = term.toLowerCase();
                this.applyFilters();
            }

            // Apply filters (search)
            applyFilters() {
                if (!this.searchTerm) {
                    this.filteredNetworks = [...this.networks];
                } else {
                    this.filteredNetworks = this.networks.filter(net => {
                        const ssid = (net.ssid || '').toLowerCase();
                        const bssid = (net.bssid || '').toLowerCase();
                        return ssid.includes(this.searchTerm) || bssid.includes(this.searchTerm);
                    });
                }
                this.displayedCount = 0; // Reset on filter change
            }

            // Load more networks (for infinite scroll)
            loadMore() {
                this.displayedCount += this.batchSize;
            }

            // Check if more networks available
            hasMore() {
                const sorted = this.getSortedNetworks();
                return this.displayedCount < sorted.length;
            }

            // Get sorted networks
            getSortedNetworks() {
                let sorted = [...this.filteredNetworks];

                if (this.currentSort.column) {
                    const col = NETWORK_COLUMNS[this.currentSort.column];
                    const direction = this.currentSort.direction === 'asc' ? 1 : -1;

                    sorted.sort((a, b) => {
                        let aVal = a[this.currentSort.column];
                        let bVal = b[this.currentSort.column];

                        // Use sortValue function if available
                        if (col.sortValue) {
                            aVal = col.sortValue(aVal);
                            bVal = col.sortValue(bVal);
                        }

                        // Handle null/undefined
                        if (aVal === null || aVal === undefined) return direction;
                        if (bVal === null || bVal === undefined) return -direction;

                        // Numeric comparison
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return (aVal - bVal) * direction;
                        }

                        // String comparison (case-insensitive)
                        const aStr = String(aVal).toLowerCase();
                        const bStr = String(bVal).toLowerCase();
                        return aStr.localeCompare(bStr) * direction;
                    });
                }

                return sorted;
            }

            // Set networks data
            setNetworks(networks) {
                this.networks = networks;
                this.applyFilters();
            }

            // Render column selector UI
            renderColumnSelector(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                const html = `
                    <div class="column-selector">
                        <button class="column-selector-btn" onclick="toggleColumnSelectorDropdown()">
                            ‚öôÔ∏è Columns
                        </button>
                        <div class="column-selector-dropdown" id="column-selector-dropdown" style="display: none;">
                            <div class="column-selector-header">
                                <span>Show/Hide Columns</span>
                                <button onclick="networkTable.resetToDefaults(); renderNetworkTable();" class="reset-btn">Reset</button>
                            </div>
                            <div class="column-selector-list">
                                ${Object.keys(NETWORK_COLUMNS).map(key => `
                                    <label class="column-selector-item">
                                        <input
                                            type="checkbox"
                                            ${this.visibleColumns.includes(key) ? 'checked' : ''}
                                            onchange="networkTable.toggleColumn('${key}'); renderNetworkTable();"
                                        />
                                        <span>${NETWORK_COLUMNS[key].label}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;

                container.innerHTML = html;
            }
        }

        // Toggle column selector dropdown
        function toggleColumnSelectorDropdown() {
            const dropdown = document.getElementById('column-selector-dropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('column-selector-dropdown');
            const btn = document.querySelector('.column-selector-btn');
            if (dropdown && btn && !dropdown.contains(e.target) && !btn.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Render network table with current settings
        function renderNetworkTable(tableId = 'networks-table', onRowClick = null, append = false) {
            if (!window.networkTable) return;

            const table = document.getElementById(tableId);
            if (!table) return;

            const tbody = table.querySelector('tbody');
            const thead = table.querySelector('thead');
            if (!tbody || !thead) return;

            // Get sorted networks
            const allNetworks = networkTable.getSortedNetworks();

            // Render table headers (unless appending)
            if (!append) {
                const headerRow = document.createElement('tr');
                networkTable.visibleColumns.forEach(colKey => {
                    const col = NETWORK_COLUMNS[colKey];
                    const th = document.createElement('th');
                    th.style.width = col.width;
                    th.textContent = col.label;

                    if (col.sortable) {
                        th.className = 'sortable';
                        th.onclick = () => {
                            networkTable.setSort(colKey);
                            renderNetworkTable(tableId, onRowClick);
                        };

                        // Add sort indicator
                        const indicator = document.createElement('span');
                        indicator.className = 'sort-indicator';
                        if (networkTable.currentSort.column === colKey) {
                            th.classList.add('sorted');
                            indicator.textContent = networkTable.currentSort.direction === 'asc' ? '‚ñ≤' : '‚ñº';
                        } else {
                            indicator.textContent = '‚ñ≤';
                        }
                        th.appendChild(indicator);
                    }

                    headerRow.appendChild(th);
                });
                thead.innerHTML = '';
                thead.appendChild(headerRow);
            }

            // Clear body if not appending
            if (!append) {
                tbody.innerHTML = '';
                networkTable.displayedCount = 0;
            }

            // Check if empty
            if (allNetworks.length === 0 && !append) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = networkTable.visibleColumns.length;
                td.className = 'loading';
                td.textContent = networkTable.searchTerm ? 'No networks found matching search' : 'No networks found';
                tr.appendChild(td);
                tbody.appendChild(tr);
                return;
            }

            // Get the batch to render
            const startIdx = networkTable.displayedCount;
            const endIdx = Math.min(startIdx + networkTable.batchSize, allNetworks.length);
            const networksToRender = allNetworks.slice(startIdx, endIdx);

            // Render networks
            networksToRender.forEach(network => {
                const tr = document.createElement('tr');
                tr.dataset.bssid = network.bssid;

                // Add click handler if provided
                if (onRowClick) {
                    tr.style.cursor = 'pointer';
                    tr.onclick = () => onRowClick(network);
                }

                networkTable.visibleColumns.forEach(colKey => {
                    const col = NETWORK_COLUMNS[colKey];
                    const td = document.createElement('td');

                    // Get value from network data
                    let value = network[colKey];

                    // Special handling for latitude/longitude from location object
                    if (colKey === 'latitude' && network.location) {
                        value = network.location.lat;
                    } else if (colKey === 'longitude' && network.location) {
                        value = network.location.lng;
                    }

                    // Format value
                    td.textContent = col.format ? col.format(value) : (value || 'N/A');

                    // Apply monospace style if needed
                    if (col.monospace) {
                        td.className = 'mono';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            // Update displayed count
            networkTable.displayedCount = endIdx;

            // Update count display
            updateNetworkCount();
        }

        // Update network count display
        function updateNetworkCount() {
            const countEl = document.getElementById('networks-count');
            if (countEl && window.networkTable) {
                const total = networkTable.networks.length;
                const filtered = networkTable.filteredNetworks.length;
                if (networkTable.searchTerm) {
                    countEl.textContent = `${filtered} / ${total}`;
                } else {
                    countEl.textContent = total;
                }
            }
        }

        // Parse security/encryption from capabilities
        function parseSecurityType(capabilities, encryption) {
            if (!capabilities && !encryption) return 'OPEN';

            const caps = (capabilities || '').toUpperCase();
            const enc = (encryption || '').toLowerCase();

            // Check for WPA3
            if (caps.includes('WPA3') || caps.includes('SAE')) {
                if (caps.includes('EAP') || caps.includes('MGT')) return 'WPA3-E';
                return 'WPA3-P';
            }

            // Check for WPA2
            if (caps.includes('WPA2') || caps.includes('RSN')) {
                if (caps.includes('EAP') || caps.includes('MGT')) return 'WPA2-E';
                return 'WPA2-P';
            }

            // Check for WPA (original)
            if (caps.includes('WPA-') && !caps.includes('WPA2')) {
                return 'WPA';
            }

            // Check for WEP
            if (caps.includes('WEP') || enc === 'wep') {
                return 'WEP';
            }

            // Check for WPS only
            if (caps.includes('WPS') && !caps.includes('WPA')) {
                return 'WPS';
            }

            // If we have encryption field
            if (enc === 'wpa3') return 'WPA3-P';
            if (enc === 'wpa2') return 'WPA2-P';
            if (enc === 'wpa') return 'WPA';
            if (enc === 'wep') return 'WEP';

            // Default
            return caps ? 'Unknown' : 'OPEN';
        }

        // Map type codes to readable names
        function getNetworkTypeName(typeCode) {
            const typeMap = {
                'W': 'WiFi',
                'E': 'BLE',
                'B': 'Bluetooth',
                'L': 'LTE',
                'N': '5G NR',
                'G': 'GSM'
            };
            return typeMap[typeCode] || typeCode || 'Unknown';
        }

        // Get network type icon SVG
        function getNetworkIcon(networkType) {
            const type = (networkType || 'wifi').toLowerCase();

            // Bluetooth icon
            if (type.includes('ble') || type.includes('bluetooth') || type === 'b' || type === 'e') {
                return `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                    <path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z"/>
                </svg>`;
            }

            // Cellular/signal tower icon
            if (type.includes('cellular') || type.includes('cell') || type.includes('gsm') || type.includes('lte') || type.includes('5g') || type === 'g' || type === 'l' || type === 'n') {
                return `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                    <path d="M17.77 3.77L16 2 6 12l10 10 1.77-1.77L9.54 12z"/>
                    <path d="M6 12l10-10 1.77 1.77L9.54 12l8.23 8.23L16 22z"/>
                    <path d="M6 12l5-5v10z"/>
                </svg>`;
            }

            // WiFi icon (default)
            return `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                <path d="M12 18.5a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3z"/>
                <path d="M12 14c-1.7 0-3.3.6-4.6 1.8a1 1 0 1 0 1.4 1.4A5 5 0 0 1 12 16a5 5 0 0 1 3.2 1.2 1 1 0 1 0 1.3-1.5A6.9 6.9 0 0 0 12 14z"/>
                <path d="M12 9.5c-3 0-5.8 1.1-8 3.2a1 1 0 1 0 1.4 1.4c1.8-1.8 4.1-2.7 6.6-2.7 2.5 0 4.8.9 6.6 2.7a1 1 0 1 0 1.4-1.4c-2.2-2.1-5.1-3.2-8-3.2z"/>
                <path d="M12 5c-4.3 0-8.3 1.6-11.3 4.6a1 1 0 1 0 1.4 1.4C4.6 7.5 8.2 6 12 6s7.4 1.5 9.9 4a1 1 0 1 0 1.4-1.4C20.3 6.6 16.3 5 12 5z"/>
            </svg>`;
        }

        // Generate Network Click Tooltip HTML
        function generateNetworkTooltip(props, coordinates, manufacturer, timestamp) {
            // Observation count (if available)
            let observationInfo = '';
            if (props.observationIndex && props.totalObservations) {
                observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
            }

            // Get network icon
            const iconSvg = getNetworkIcon(props.type);

            // Signal strength with color class
            const signal = props.signal || 'N/A';
            let signalClass = '';
            if (signal !== 'N/A') {
                if (signal >= -50) signalClass = 'signal-strong';
                else if (signal >= -70) signalClass = 'signal-medium';
                else signalClass = 'signal-weak';
            }

            // Distance from home
            let distanceFromHome = '';
            if (props.distanceFromHome) {
                distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
            }

            // Build tooltip HTML
            return `
                <div class="dark-tooltip">
                    ${observationInfo}
                    <div class="tooltip-header">
                        <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                        ${iconSvg}
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">BSSID:</span>
                        <span class="tooltip-value mono">${props.bssid}</span>
                    </div>
                    ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Signal:</span>
                        <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">Security:</span>
                        <span class="tooltip-value">${props.security || 'Unknown'}</span>
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">Type:</span>
                        <span class="tooltip-value">${props.typeDisplay || getNetworkTypeName(props.type)}</span>
                    </div>
                    ${distanceFromHome}
                    <div class="tooltip-timestamp">
                        <span class="tooltip-label">Last seen:</span>
                        <span class="tooltip-value">${timestamp}</span>
                    </div>
                </div>
            `;
        }

        // Generate Observation Point Click Tooltip HTML
        function generateObservationClickTooltip(props, coordinates, manufacturer, seenBy, time) {
            // Observation sequence header
            const observationHeader = `<div class="observation-header">Observation #${props.sequence} of ${props.total}</div>`;

            // Get network icon
            const iconSvg = getNetworkIcon(props.type);

            // Signal strength with color class
            const signal = props.signal || 'N/A';
            let signalClass = '';
            if (signal !== 'N/A') {
                if (signal >= -50) signalClass = 'signal-strong';
                else if (signal >= -70) signalClass = 'signal-medium';
                else signalClass = 'signal-weak';
            }

            // Altitude (if exists)
            let altitudeField = '';
            if (props.altitude !== undefined && props.altitude !== null) {
                altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
            }

            // Accuracy (if exists)
            let accuracyField = '';
            if (props.accuracy !== undefined && props.accuracy !== null) {
                accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
            }

            // Distance from home (required)
            const distanceFromHome = props.distance_from_home !== undefined
                ? parseFloat(props.distance_from_home).toFixed(2)
                : '0.00';

            // Seen by (optional)
            let seenByField = '';
            if (seenBy) {
                seenByField = `<div class="tooltip-field"><span class="tooltip-label">Seen by:</span><span class="tooltip-value">${seenBy}</span></div>`;
            }

            // Build tooltip HTML
            return `
                <div class="dark-tooltip">
                    ${observationHeader}
                    <div class="tooltip-header">
                        <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                        ${iconSvg}
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">BSSID:</span>
                        <span class="tooltip-value mono">${props.bssid}</span>
                    </div>
                    ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Signal:</span>
                        <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                    </div>
                    ${altitudeField}
                    ${accuracyField}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Distance from Home:</span>
                        <span class="tooltip-value">${distanceFromHome} km</span>
                    </div>
                    ${seenByField}
                    <div class="tooltip-timestamp">
                        <span class="tooltip-label">Time:</span>
                        <span class="tooltip-value">${time}</span>
                    </div>
                </div>
            `;
        }

        // Generate Observation Point Hover Tooltip HTML (includes range radius)
        function generateObservationHoverTooltip(props, coordinates, manufacturer, hoverSeenBy, time, radiusMeters) {
            // Observation sequence header
            const observationHeader = `<div class="observation-header">Observation #${props.sequence} of ${props.total}</div>`;

            // Get network icon
            const iconSvg = getNetworkIcon(props.type);

            // Signal strength with color class
            const signal = props.signal || 'N/A';
            let signalClass = '';
            if (signal !== 'N/A') {
                if (signal >= -50) signalClass = 'signal-strong';
                else if (signal >= -70) signalClass = 'signal-medium';
                else signalClass = 'signal-weak';
            }

            // Altitude (if exists)
            let altitudeField = '';
            if (props.altitude !== undefined && props.altitude !== null) {
                altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
            }

            // Accuracy (if exists)
            let accuracyField = '';
            if (props.accuracy !== undefined && props.accuracy !== null) {
                accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
            }

            // Distance from home (required)
            const distanceFromHome = props.distance_from_home !== undefined
                ? parseFloat(props.distance_from_home).toFixed(2)
                : '0.00';

            // Range radius field (HOVER ONLY)
            let rangeField = '';
            if (radiusMeters !== undefined && radiusMeters !== null) {
                rangeField = `<div class="tooltip-field"><span class="tooltip-label">Range:</span><span class="tooltip-value">${radiusMeters}m radius</span></div>`;
            }

            // Seen by (optional)
            let seenByField = '';
            if (hoverSeenBy) {
                seenByField = `<div class="tooltip-field"><span class="tooltip-label">Seen by:</span><span class="tooltip-value">${hoverSeenBy}</span></div>`;
            }

            // Build tooltip HTML
            return `
                <div class="dark-tooltip">
                    ${observationHeader}
                    <div class="tooltip-header">
                        <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                        ${iconSvg}
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">BSSID:</span>
                        <span class="tooltip-value mono">${props.bssid}</span>
                    </div>
                    ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Signal:</span>
                        <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                    </div>
                    ${altitudeField}
                    ${accuracyField}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Distance from Home:</span>
                        <span class="tooltip-value">${distanceFromHome} km</span>
                    </div>
                    ${rangeField}
                    ${seenByField}
                    <div class="tooltip-timestamp">
                        <span class="tooltip-label">Time:</span>
                        <span class="tooltip-value">${time}</span>
                    </div>
                </div>
            `;
        }

        // Manufacturer lookup from BSSID (OUI-based)
        async function getManufacturerFromBSSID(bssid) {
            if (!bssid) return null;

            // Try API first for complete database
            try {
                const response = await fetch(`${API_BASE_URL}/api/manufacturer/${bssid}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.manufacturer) return data.manufacturer;
                }
            } catch (err) {
                console.warn('API manufacturer lookup failed, using local map');
            }

            // Fallback to local OUI map
            const oui = bssid.substring(0, 8).toUpperCase().replace(/:/g, '');

            // Common manufacturers (simplified lookup)
            const ouiMap = {
                '00037F': 'Atheros',
                '000393': 'Apple',
                '000502': 'Apple',
                '000D93': 'Apple',
                '001124': 'Apple',
                '0016CB': 'Apple',
                '001B63': 'Apple',
                '001EC2': 'Apple',
                '0021E9': 'Apple',
                '002312': 'Apple',
                '002490': 'Apple',
                '0025BC': 'Apple',
                '003065': 'Apple',
                '0050E4': 'Apple',
                '00A040': 'Apple',
                '00F4B9': 'Apple',
                '04489A': 'Apple',
                '0C7132': 'Apple',
                '10417F': 'Apple',
                '101C0C': 'Apple',
                '1C36BB': 'Apple',
                '28E02C': 'Apple',
                '28E14C': 'Apple',
                '34159E': 'Apple',
                '34AB37': 'Apple',
                '3C0754': 'Apple',
                '50EAD6': 'Apple',
                '5C5948': 'Apple',
                '5CF938': 'Apple',
                '680927': 'Apple',
                '68967B': 'Apple',
                '6C94F8': 'Apple',
                '70CD60': 'Apple',
                '78A3E4': 'Apple',
                '7C04D0': 'Apple',
                '7CD1C3': 'Apple',
                '8C5877': 'Apple',
                '90B21F': 'Apple',
                '9C207B': 'Apple',
                'A4C361': 'Apple',
                'B019C6': 'Apple',
                'B853AC': 'Apple',
                'C82A14': 'Apple',
                'D023DB': 'Apple',
                'D4F46F': 'Apple',
                'DC2B2A': 'Apple',
                'E0F847': 'Apple',
                'F0D1A9': 'Apple',
                'F82793': 'Apple',
                '001D7E': 'Motorola',
                '000C41': 'Motorola',
                '000E5C': 'Motorola',
                '000FB3': 'Motorola',
                '000FCF': 'Motorola',
                '001620': 'Motorola',
                '001A1B': 'Motorola',
                '00215D': 'Motorola',
                '002197': 'Motorola',
                '0C3021': 'Motorola',
                '18F46A': 'Motorola',
                '00E04C': 'Realtek',
                '000BDB': 'Dell',
                '00B0D0': 'Dell',
                '001C23': 'Dell',
                '00072F': 'Cisco',
                '000A8A': 'Cisco',
                '000142': 'Cisco',
                '001279': 'Cisco'
            };

            return ouiMap[oui] || null;
        }

        // Convert decimal degrees to DMS (Degrees Minutes Seconds)
        function decimalToDMS(decimal, isLat) {
            const absolute = Math.abs(decimal);
            const degrees = Math.floor(absolute);
            const minutesFloat = (absolute - degrees) * 60;
            const minutes = Math.floor(minutesFloat);
            const seconds = ((minutesFloat - minutes) * 60).toFixed(2);

            const direction = isLat
                ? (decimal >= 0 ? 'N' : 'S')
                : (decimal >= 0 ? 'E' : 'W');

            return `${degrees}¬∞ ${minutes}' ${seconds}" ${direction}`;
        }

        // Highlight active nav
        function highlightActiveNav() {
            const currentPath = window.location.pathname;
            document.querySelectorAll('a.nav-link').forEach(link => {
                link.classList.remove('active');
                const href = link.getAttribute('href');

                if ((currentPath === '/' || currentPath === '/index.html') && (href === '/' || href === '/index.html')) {
                    link.classList.add('active');
                } else if (href !== '/' && currentPath.includes(href.replace('/', ''))) {
                    link.classList.add('active');
                }
            });
        }

        // Initialize map
        function initMap() {
            if (map) return;

            // Mapbox token should be set via environment variable and served by backend
            // For now, using a public token - replace with your own token
            mapboxgl.accessToken = 'REDACTED_MAPBOX_TOKEN_2';
            // TODO: Fetch token from API endpoint instead: fetch('/api/mapbox-token').then(r => r.json()).then(data => mapboxgl.accessToken = data.token)

            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/dark-v11',
                center: [-83.69, 43.02],
                zoom: 12
            });

            map.on('load', () => {
                console.log('‚úì Map initialized - click a threat to view observations');
                // Don't load points initially - user selects threat first
            });

            map.addControl(new mapboxgl.NavigationControl(), 'top-right');
        }

        // Load observations for a specific BSSID and render with sequence numbers
        async function loadObservationsToMap(bssid, ssid) {
            if (!map) return;

            try {
                console.log(`üìç Loading observations for ${bssid}...`);
                const res = await fetch(`${API_BASE}/networks/observations/${bssid}`);

                if (!res.ok) {
                    console.error('‚úó Observations API failed:', res.status);
                    return;
                }

                const data = await res.json();

                if (!data.ok || !data.observations || data.observations.length === 0) {
                    console.warn('‚ö†Ô∏è No observations found for this BSSID');
                    return;
                }

                const observations = data.observations;
                const totalObservations = observations.length;

                console.log(`‚úì Found ${totalObservations} observations`);

                // Sort by timestamp to get temporal sequence
                observations.sort((a, b) => parseInt(a.time) - parseInt(b.time));

                // Create GeoJSON features with observation index
                const features = observations.map((obs, index) => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [obs.lon, obs.lat]
                    },
                    properties: {
                        bssid: obs.bssid,
                        ssid: obs.ssid || ssid || 'Hidden',
                        type: obs.type || 'W',
                        typeDisplay: getNetworkTypeName(obs.type || 'W'),
                        signal: obs.signal,
                        security: parseSecurityType(obs.capabilities, obs.encryption),
                        capabilities: obs.capabilities || '',
                        encryption: obs.encryption || '',
                        status: 'threat',
                        lastSeen: obs.time,
                        distanceFromHome: obs.distance_from_home_km,
                        altitude: obs.alt,
                        accuracy: obs.acc,
                        observationIndex: index + 1,
                        totalObservations: totalObservations
                    }
                }));

                // Remove existing layers and sources
                if (map.getLayer('network-labels')) {
                    map.removeLayer('network-labels');
                }
                if (map.getLayer('network-points')) {
                    map.removeLayer('network-points');
                }
                if (map.getLayer('threat-path')) {
                    map.removeLayer('threat-path');
                }
                if (map.getSource('networks')) {
                    map.removeSource('networks');
                }
                if (map.getSource('threat-path')) {
                    map.removeSource('threat-path');
                }

                // Create temporal path line from observations
                const pathCoordinates = observations.map(obs => [obs.lon, obs.lat]);
                map.addSource('threat-path', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: pathCoordinates
                        }
                    }
                });

                // Add line connecting observations (movement path)
                map.addLayer({
                    id: 'threat-path',
                    type: 'line',
                    source: 'threat-path',
                    layout: {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    paint: {
                        'line-color': '#ef4444',
                        'line-width': 2,
                        'line-opacity': 0.6
                    }
                });

                // Add observation points source
                map.addSource('networks', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    }
                });

                // Add circle layer
                map.addLayer({
                    id: 'network-points',
                    type: 'circle',
                    source: 'networks',
                    paint: {
                        'circle-radius': 12,
                        'circle-color': '#ef4444', // Red for threats
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.9
                    }
                });

                // Add numbered labels on markers
                map.addLayer({
                    id: 'network-labels',
                    type: 'symbol',
                    source: 'networks',
                    layout: {
                        'text-field': ['get', 'observationIndex'],
                        'text-font': ['DIN Pro Bold', 'Arial Unicode MS Bold'],
                        'text-size': 11,
                        'text-allow-overlap': true,
                        'text-ignore-placement': true
                    },
                    paint: {
                        'text-color': '#ffffff',
                        'text-halo-color': '#000000',
                        'text-halo-width': 1
                    }
                });

                // Add popup on click
                map.on('click', 'network-points', async (e) => {
                    const props = e.features[0].properties;
                    const coords = e.lngLat;

                    // Format timestamp
                    const timestamp = props.lastSeen ? new Date(parseInt(props.lastSeen)).toLocaleString() : 'Unknown';

                    // Manufacturer lookup
                    const manufacturer = props.bssid ? await getManufacturerFromBSSID(props.bssid) : null;

                    // Convert coordinates to DMS
                    const latDMS = decimalToDMS(coords.lat, true);
                    const lngDMS = decimalToDMS(coords.lng, false);

                    // Altitude field
                    let altitudeField = '';
                    if (props.altitude !== undefined && props.altitude !== null && props.altitude !== 'null') {
                        altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
                    }

                    // Accuracy field
                    let accuracyField = '';
                    if (props.accuracy !== undefined && props.accuracy !== null && props.accuracy !== 'null') {
                        accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
                    }

                    // Distance from home
                    let distanceFromHome = '';
                    if (props.distanceFromHome) {
                        distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
                    }

                    // Observation count (temporal sequence)
                    let observationInfo = '';
                    if (props.observationIndex && props.totalObservations) {
                        observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
                    }

                    // Network type icon
                    const iconSvg = getNetworkIcon(props.type);

                    // Signal strength with color class
                    const signal = props.signal || 'N/A';
                    let signalClass = '';
                    if (signal !== 'N/A') {
                        if (signal >= -50) signalClass = 'signal-strong';
                        else if (signal >= -70) signalClass = 'signal-medium';
                        else signalClass = 'signal-weak';
                    }

                    const popup = new mapboxgl.Popup({
                        className: 'dark-tooltip-popup',
                        closeButton: true,
                        closeOnClick: true,
                        maxWidth: '320px'
                    })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="dark-tooltip" style="cursor: pointer;">
                                ${observationInfo}
                                <div class="tooltip-header">
                                    <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                                    ${iconSvg}
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">BSSID:</span>
                                    <span class="tooltip-value mono">${props.bssid}</span>
                                </div>
                                ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Coordinates:</span>
                                    <span class="tooltip-value mono">${latDMS}<br>${lngDMS}</span>
                                </div>
                                ${altitudeField}
                                ${accuracyField}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Type:</span>
                                    <span class="tooltip-value">${props.typeDisplay || getNetworkTypeName(props.type)}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Security:</span>
                                    <span class="tooltip-value">${props.security}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Signal:</span>
                                    <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                                </div>
                                ${distanceFromHome}
                                <div class="tooltip-timestamp">
                                    <span class="tooltip-label">Observed at:</span>
                                    <span class="tooltip-value">${timestamp}</span>
                                </div>
                            </div>
                        `)
                        .addTo(map);

                    // Add click-to-close functionality
                    setTimeout(() => {
                        const tooltipEl = popup.getElement();
                        if (tooltipEl) {
                            const contentEl = tooltipEl.querySelector('.dark-tooltip');
                            if (contentEl) {
                                contentEl.addEventListener('click', () => popup.remove());
                            }
                        }
                    }, 0);
                });

                map.on('mouseenter', 'network-points', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });

                map.on('mouseleave', 'network-points', () => {
                    map.getCanvas().style.cursor = '';
                });

                // Fit map to show all observations
                const coords = observations.map(obs => [obs.lon, obs.lat]);
                const bounds = coords.reduce((bounds, coord) => {
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coords[0], coords[0]));

                map.fitBounds(bounds, { padding: 50 });

                console.log(`‚úì Rendered ${features.length} observations with sequence numbers and tooltips`);
            } catch (err) {
                console.error('‚úó Error loading observations to map:', err);
            }
        }

        // Load networks and add to map
        async function loadNetworksToMap() {
            if (!map) return;

            try {
                console.log('üìç Loading networks to map...');
                const res = await fetch(`${API_BASE}/networks?page=1&limit=5000&sort=lastSeen&order=DESC`);

                if (!res.ok) {
                    console.error('‚úó API request failed:', res.status);
                    return;
                }

                const data = await res.json();
                const networks = data.networks || [];

                // Fetch tagged networks to apply visual styling
                const [threatsRes, safeRes] = await Promise.all([
                    fetch(`${API_BASE}/networks/tagged?tag_type=THREAT`).catch(err => {
                        console.warn('Failed to fetch threats:', err);
                        return { ok: false };
                    }),
                    fetch(`${API_BASE}/networks/tagged?tag_type=FALSE_POSITIVE`).catch(err => {
                        console.warn('Failed to fetch safe networks:', err);
                        return { ok: false };
                    })
                ]);

                const threatsData = threatsRes.ok ? await threatsRes.json() : { ok: false, networks: [] };
                const safeData = safeRes.ok ? await safeRes.json() : { ok: false, networks: [] };

                const threatBssids = new Set((threatsData.networks || []).map(n => n.bssid));
                const safeBssids = new Set((safeData.networks || []).map(n => n.bssid));

                console.log(`üè∑Ô∏è Found ${threatBssids.size} confirmed threats, ${safeBssids.size} safe networks`);

                if (!Array.isArray(networks) || networks.length === 0) {
                    console.warn('‚ö†Ô∏è No networks returned from API');
                    return;
                }

                // Filter networks with valid coordinates
                const validNetworks = networks.filter(n =>
                    n.location &&
                    n.location.lat !== null && n.location.lat !== undefined &&
                    n.location.lng !== null && n.location.lng !== undefined &&
                    !isNaN(n.location.lat) && !isNaN(n.location.lng)
                );

                console.log(`‚úì Found ${validNetworks.length} networks with valid coordinates out of ${networks.length} total`);

                // Create GeoJSON features with tag-based status
                const features = validNetworks.map(net => {
                    let status = 'normal';
                    if (threatBssids.has(net.bssid)) {
                        status = 'threat';
                    } else if (safeBssids.has(net.bssid)) {
                        status = 'safe';
                    }

                    return {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [net.location.lng, net.location.lat]
                        },
                        properties: {
                            bssid: net.bssid || 'Unknown',
                            ssid: net.ssid || 'Hidden',
                            type: net.type || 'W',
                            signal: net.signal || 'N/A',
                            security: net.security || 'Unknown',
                            status: status
                        }
                    };
                });

                // Remove old layers first (must remove layers before source)
                if (map.getLayer('network-points')) {
                    map.removeLayer('network-points');
                }
                if (map.getLayer('cluster-count')) {
                    map.removeLayer('cluster-count');
                }
                if (map.getLayer('clusters')) {
                    map.removeLayer('clusters');
                }

                // Remove and add source with clustering
                if (map.getSource('networks')) {
                    map.removeSource('networks');
                }

                map.addSource('networks', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    },
                    cluster: true,
                    clusterMaxZoom: 16, // Max zoom to cluster points on
                    clusterRadius: 50 // Radius of each cluster when clustering points
                });

                // Add cluster circles layer
                map.addLayer({
                    id: 'clusters',
                    type: 'circle',
                    source: 'networks',
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#3b82f6', 10,
                            '#f59e0b', 50,
                            '#ef4444'
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            15, 10,
                            20, 50,
                            25
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                });

                // Add cluster count labels
                map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    source: 'networks',
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });

                // Add unclustered points layer
                map.addLayer({
                    id: 'network-points',
                    type: 'circle',
                    source: 'networks',
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-radius': 8,
                        'circle-color': [
                            'match',
                            ['get', 'status'],
                            'threat', '#ef4444',      // Red for confirmed threats
                            'warning', '#f59e0b',     // Orange for warnings
                            'safe', '#10b981',        // Green for safe networks
                            '#3b82f6'                 // Blue for normal/untoggled networks
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': [
                            'match',
                            ['get', 'status'],
                            'threat', 1.0,            // Full opacity for threats (highlight)
                            'safe', 0.3,              // Dimmed for safe networks
                            0.7                       // Normal opacity for untoggled
                        ]
                    }
                });

                // Click handler for clusters - zoom in
                map.on('click', 'clusters', (e) => {
                    const features = map.queryRenderedFeatures(e.point, {
                        layers: ['clusters']
                    });
                    const clusterId = features[0].properties.cluster_id;
                    map.getSource('networks').getClusterExpansionZoom(
                        clusterId,
                        (err, zoom) => {
                            if (err) return;
                            map.easeTo({
                                center: features[0].geometry.coordinates,
                                zoom: zoom
                            });
                        }
                    );
                });

                // Change cursor on cluster hover
                map.on('mouseenter', 'clusters', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', 'clusters', () => {
                    map.getCanvas().style.cursor = '';
                });

                // Add popup on click for unclustered points
                map.on('click', 'network-points', async (e) => {
                    const props = e.features[0].properties;

                    // Format timestamp
                    const timestamp = props.lastSeen ? new Date(parseInt(props.lastSeen)).toLocaleString() : 'Unknown';

                    // Manufacturer lookup (simple OUI-based)
                    const manufacturer = props.bssid ? await getManufacturerFromBSSID(props.bssid) : null;

                    // Calculate distance from home if available
                    let distanceFromHome = '';
                    if (props.distanceFromHome) {
                        distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
                    }

                    // Observation count (temporal sequence)
                    let observationInfo = '';
                    if (props.observationIndex && props.totalObservations) {
                        observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
                    }

                    // Determine icon based on network type
                    const networkType = (props.type || 'wifi').toLowerCase();
                    let iconSvg = '';
                    if (networkType.includes('ble') || networkType.includes('bluetooth') || networkType === 'b' || networkType === 'e') {
                        // Bluetooth icon
                        iconSvg = `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                            <path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z"/>
                        </svg>`;
                    } else if (networkType.includes('cellular') || networkType.includes('cell') || networkType.includes('gsm') || networkType.includes('lte') || networkType.includes('5g') || networkType === 'g' || networkType === 'l' || networkType === 'n') {
                        // Cellular/signal tower icon
                        iconSvg = `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                            <path d="M17.77 3.77L16 2 6 12l10 10 1.77-1.77L9.54 12z"/>
                            <path d="M6 12l10-10 1.77 1.77L9.54 12l8.23 8.23L16 22z"/>
                            <path d="M6 12l5-5v10z"/>
                        </svg>`;
                    } else {
                        // WiFi icon (default)
                        iconSvg = `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                            <path d="M12 18.5a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3z"/>
                            <path d="M12 14c-1.7 0-3.3.6-4.6 1.8a1 1 0 1 0 1.4 1.4A5 5 0 0 1 12 16a5 5 0 0 1 3.2 1.2 1 1 0 1 0 1.3-1.5A6.9 6.9 0 0 0 12 14z"/>
                            <path d="M12 9.5c-3 0-5.8 1.1-8 3.2a1 1 0 1 0 1.4 1.4c1.8-1.8 4.1-2.7 6.6-2.7 2.5 0 4.8.9 6.6 2.7a1 1 0 1 0 1.4-1.4c-2.2-2.1-5.1-3.2-8-3.2z"/>
                            <path d="M12 5c-4.3 0-8.3 1.6-11.3 4.6a1 1 0 1 0 1.4 1.4C4.6 7.5 8.2 6 12 6s7.4 1.5 9.9 4a1 1 0 1 0 1.4-1.4C20.3 6.6 16.3 5 12 5z"/>
                        </svg>`;
                    }

                    const popup = new mapboxgl.Popup({
                        className: 'dark-tooltip-popup',
                        closeButton: true,
                        closeOnClick: true,
                        maxWidth: '320px'
                    })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="dark-tooltip" style="cursor: pointer;">
                                ${observationInfo}
                                <div class="tooltip-header">
                                    <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                                    ${iconSvg}
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">BSSID:</span>
                                    <span class="tooltip-value mono">${props.bssid}</span>
                                </div>
                                ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Signal:</span>
                                    <span class="tooltip-value signal-${props.signal >= -50 ? 'strong' : props.signal >= -70 ? 'medium' : 'weak'}">${props.signal} dBm</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Security:</span>
                                    <span class="tooltip-value">${props.security || 'Unknown'}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Type:</span>
                                    <span class="tooltip-value">${props.type}</span>
                                </div>
                                ${distanceFromHome}
                                <div class="tooltip-timestamp">
                                    <span class="tooltip-label">Last seen:</span>
                                    <span class="tooltip-value">${timestamp}</span>
                                </div>
                            </div>
                        `)
                        .addTo(map);

                    // Add click-to-close functionality
                    setTimeout(() => {
                        const tooltipEl = popup.getElement();
                        if (tooltipEl) {
                            const contentEl = tooltipEl.querySelector('.dark-tooltip');
                            if (contentEl) {
                                contentEl.addEventListener('click', () => popup.remove());
                            }
                        }
                    }, 0);
                });

                map.on('mouseenter', 'network-points', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });

                map.on('mouseleave', 'network-points', () => {
                    map.getCanvas().style.cursor = '';
                });

                console.log(`‚úì Added ${features.length} network markers to map`);
            } catch (err) {
                console.error('Error loading networks to map:', err);
            }
        }

        function changeMapStyle(style) {
            if (!map) return;

            const styleMap = {
                'night': 'mapbox://styles/mapbox/standard',
                'dawn': 'mapbox://styles/mapbox/standard',
                'dusk': 'mapbox://styles/mapbox/standard',
                'day': 'mapbox://styles/mapbox/standard',
                'dark': 'mapbox://styles/mapbox/dark-v11',
                'satellite': 'mapbox://styles/mapbox/satellite-v9'
            };

            const center = map.getCenter();
            const zoom = map.getZoom();

            map.setStyle(styleMap[style]);
            map.once('style.load', () => {
                map.setCenter(center);
                map.setZoom(zoom);
                if (style !== 'dark' && style !== 'satellite') {
                    map.setConfigProperty('basemap', 'lightPreset', style);
                }
                // Don't reload points on style change - user selects threat
            });
        }

        function centerMapOnLocation() {
            if (map) {
                map.flyTo({ center: [-83.69, 43.02], zoom: 12 });
            }
        }

        // Get severity class based on threat score
        function getSeverityClass(score) {
            if (score >= 80) return 'severity-critical';
            if (score >= 70) return 'severity-high';
            if (score >= 50) return 'severity-medium';
            return 'severity-low';
        }

        // Get severity label based on threat score
        function getSeverityLabel(score) {
            if (score >= 80) return 'Critical';
            if (score >= 70) return 'High';
            if (score >= 50) return 'Medium';
            return 'Low';
        }

        // Tag a network as safe or threat
        async function tagNetwork(bssid, tagType, confidence = 50) {
            try {
                const response = await fetch(`${API_BASE}/tag-network`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        bssid: bssid,
                        tag_type: tagType,
                        confidence: confidence,
                        notes: `User tagged as ${tagType}`
                    })
                });

                if (!response.ok) {
                    console.error('‚úó Tag network failed:', response.status);
                    return false;
                }

                const result = await response.json();
                console.log(`‚úì Network tagged: ${bssid} as ${tagType}`);

                // Reload the threat list to reflect changes
                await loadThreats(false);
                return true;
            } catch (err) {
                console.error('‚úó Error tagging network:', err);
                return false;
            }
        }

        // Threats infinite scroll state
        let threatPage = 1;
        let allThreatsLoaded = false;
        let minThreatSeverity = 'all'; // Default: show all
        let selectedThreatType = ''; // Default: show all types

        async function loadThreats(append = false) {
            try {
                // Always fetch all threats, then filter client-side
                const url = `${API_BASE}/threats/quick?page=${threatPage}&limit=200`;

                const res = await fetch(url);
                const data = await res.json();

                const threatList = document.getElementById('threat-list');
                const threatsCount = document.getElementById('threats-count');

                if (!append) {
                    threatList.innerHTML = '';
                    threatPage = 1;
                    allThreatsLoaded = false;
                }

                if (!data.threats || data.threats.length === 0) {
                    if (!append) {
                        threatList.innerHTML = '<div class="loading">No threats detected</div>';
                        if (threatsCount) threatsCount.textContent = '0';
                    }
                    allThreatsLoaded = true;
                    return;
                }

                // Filter threats by selected severity level and type
                let filteredThreats = data.threats;
                if (minThreatSeverity !== 'all') {
                    filteredThreats = filteredThreats.filter(threat => {
                        const severityClass = getSeverityClass(threat.threatScore);
                        return severityClass === `severity-${minThreatSeverity}`;
                    });
                }
                
                if (selectedThreatType) {
                    filteredThreats = filteredThreats.filter(threat => threat.type === selectedThreatType);
                }

                if (filteredThreats.length === 0) {
                    if (!append) {
                        threatList.innerHTML = '<div class="loading">No threats match filters</div>';
                        if (threatsCount) threatsCount.textContent = '0';
                    }
                    allThreatsLoaded = true;
                    return;
                }

                // Update count with total from API
                if (!append && threatsCount) {
                    threatsCount.textContent = data.total || filteredThreats.length;
                }

                // Check if we got fewer threats than requested (end of list)
                if (data.threats.length < 200) {
                    allThreatsLoaded = true;
                }

                filteredThreats.forEach(threat => {
                    const row = document.createElement('div');
                    const severityClass = getSeverityClass(threat.threatScore);
                    const severityLabel = getSeverityLabel(threat.threatScore);

                    row.className = `threat-row ${severityClass}`;
                    row.innerHTML = `
                        <div style="flex: 1; min-width: 0;">
                            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                <div style="font-weight: 600; font-size: 13px; color: #f1f5f9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    ${escapeHtml(threat.ssid) || 'Hidden Network'}
                                </div>
                                <span class="threat-score ${severityClass}">${escapeHtml(severityLabel)}: ${threat.threatScore}</span>
                            </div>
                            <div style="font-size: 11px; color: #94a3b8; margin-top: 2px;">
                                ${escapeHtml(threat.bssid)} ‚Ä¢ ${threat.totalObservations} obs ‚Ä¢ ${new Date(parseInt(threat.firstSeen)).toLocaleDateString()} - ${new Date(parseInt(threat.lastSeen)).toLocaleDateString()} (${threat.timespanDays}d)
                            </div>
                        </div>
                        <div style="display: flex; gap: 4px; flex-shrink: 0;">
                            <button class="tag-safe-btn" style="
                                background: rgba(34, 197, 94, 0.2);
                                border: 1px solid rgba(34, 197, 94, 0.4);
                                color: #4ade80;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                font-weight: 600;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Mark as safe">‚úì Safe</button>
                            <button class="tag-threat-btn" style="
                                background: rgba(239, 68, 68, 0.2);
                                border: 1px solid rgba(239, 68, 68, 0.4);
                                color: #f87171;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                font-weight: 600;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Confirm threat">‚ö† Threat</button>
                            <button class="map-btn" style="
                                background: rgba(59, 130, 246, 0.2);
                                border: 1px solid rgba(59, 130, 246, 0.4);
                                color: #60a5fa;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                font-weight: 600;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Show on map">üìç Map</button>
                        </div>
                    `;

                    // Add event listeners for tagging buttons
                    const safeBtn = row.querySelector('.tag-safe-btn');
                    const threatBtn = row.querySelector('.tag-threat-btn');
                    const mapBtn = row.querySelector('.map-btn');

                    safeBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        safeBtn.style.animation = 'flash 0.3s ease';
                        setTimeout(() => safeBtn.style.animation = '', 300);
                        await tagNetwork(threat.bssid, 'FALSE_POSITIVE', 90);
                    });

                    threatBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        threatBtn.style.animation = 'flash 0.3s ease';
                        setTimeout(() => threatBtn.style.animation = '', 300);
                        await tagNetwork(threat.bssid, 'THREAT', 90);
                    });

                    mapBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        mapBtn.style.animation = 'flash 0.3s ease';
                        setTimeout(() => mapBtn.style.animation = '', 300);
                        loadObservationsToMap(threat.bssid, threat.ssid);
                        
                        // Highlight selected threat
                        document.querySelectorAll('.threat-row').forEach(r => {
                            r.style.background = '';
                            r.style.opacity = '0.6';
                        });
                        row.style.background = 'rgba(59, 130, 246, 0.2)';
                        row.style.opacity = '1';
                    });

                    // Add click handler to load observations (same as map button)
                    row.style.cursor = 'pointer';
                    row.addEventListener('click', () => {
                        console.log(`üéØ Threat selected: ${threat.ssid || 'Hidden'} (${threat.bssid})`);
                        loadObservationsToMap(threat.bssid, threat.ssid);

                        // Highlight selected threat
                        document.querySelectorAll('.threat-row').forEach(r => {
                            r.style.background = '';
                            r.style.opacity = '0.6';
                        });
                        row.style.background = 'rgba(59, 130, 246, 0.2)';
                        row.style.opacity = '1';
                    });

                    threatList.appendChild(row);
                });

                console.log(`‚úì Loaded ${data.threats.length} threats (page ${threatPage})`);
            } catch (err) {
                console.error('Error loading threats:', err);
            }
        }

        // Initialize network table manager (abbreviated mode for geospatial)
        let networkTable = null;

        async function loadNetworks() {
            try {
                console.log('üì° Loading recent networks...');
                const res = await fetch(`${API_BASE}/networks?page=1&limit=1000&sort=lastSeen&order=DESC`);

                if (!res.ok) {
                    console.error('‚úó Networks API failed:', res.status);
                    const tbody = document.querySelector('#networks-table tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="4" class="loading">API Error: ' + res.status + '</td></tr>';
                    }
                    return;
                }

                const data = await res.json();
                let networks = data.networks || [];
                console.log(`üì° API returned ${networks?.length || 0} networks (total: ${data.totalCount || 0})`);

                if (!Array.isArray(networks) || networks.length === 0) {
                    console.warn('‚ö†Ô∏è No networks returned from API');
                    const tbody = document.querySelector('#networks-table tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="4" class="loading">No networks found</td></tr>';
                    }
                    return;
                }

                // Initialize table manager with full grid (same as networks page)
                if (!networkTable) {
                    console.log('üìä Initializing NetworkTableManager for geospatial...');
                    networkTable = new NetworkTableManager('geospatial', false);
                    window.networkTable = networkTable; // Make globally accessible
                }

                // Enrich network data with formatted fields
                networks = networks.map(net => {
                    const parsedSecurity = parseSecurityType(net.capabilities, net.encryption);
                    if (window.DEBUG_SECURITY) {
                        console.log('Security parse:', {
                            capabilities: net.capabilities,
                            encryption: net.encryption,
                            result: parsedSecurity
                        });
                    }
                    return {
                        ...net,
                        type: net.type || 'W',
                        typeDisplay: getNetworkTypeName(net.type),
                        security: parsedSecurity,
                        timestamp: net.lastSeen || net.time || Date.now(),
                        observations: net.observationCount || 1,
                        latitude: net.location?.lat,
                        longitude: net.location?.lng
                    };
                });

                console.log(`üìä Enriched ${networks.length} networks, setting data...`);

                // Set networks data (no artificial limits)
                networkTable.setNetworks(networks);

                console.log(`üìä Rendering table with ${networkTable.filteredNetworks.length} filtered networks...`);

                // Render table with click handler to load observations and render on map
                renderNetworkTable('networks-table', (network) => {
                    console.log(`üì° Network selected: ${network.ssid || 'Hidden'} (${network.bssid})`);
                    loadObservationsToMap(network.bssid, network.ssid);
                    handleNetworkRowClick(network); // Render network on map

                    // Highlight selected row
                    document.querySelectorAll('#networks-table tbody tr').forEach(r => {
                        r.style.background = '';
                    });
                    const selectedRow = document.querySelector(`#networks-table tbody tr[data-bssid="${network.bssid}"]`);
                    if (selectedRow) {
                        selectedRow.style.background = 'rgba(59, 130, 246, 0.2)';
                    }
                });

                console.log(`‚úì Displayed ${networkTable.displayedCount} of ${networkTable.filteredNetworks.length} networks in table`);
            } catch (err) {
                console.error('‚úó Error loading networks:', err);
                const tbody = document.querySelector('#networks-table tbody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="4" class="loading">Error: ' + err.message + '</td></tr>';
                }
            }
        }

        // Check for URL parameters and auto-load threat observations
        function checkURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const bssid = urlParams.get('bssid');
            const ssid = urlParams.get('ssid');

            if (bssid) {
                console.log(`üéØ URL parameter detected - auto-loading observations for ${bssid}`);
                // Wait for map to initialize, then load observations
                const checkMapInterval = setInterval(() => {
                    if (map) {
                        clearInterval(checkMapInterval);
                        loadObservationsToMap(bssid, ssid || 'Unknown');
                    }
                }, 100);
            }
        }

        // Initialize on load
        // Setup infinite scroll for both threats and networks panels
        function setupInfiniteScroll() {
            // Threats panel infinite scroll
            const threatsPanel = document.querySelector('#threats-panel .panel-content');
            if (threatsPanel) {
                let isLoadingThreats = false;

                threatsPanel.addEventListener('scroll', () => {
                    if (isLoadingThreats || allThreatsLoaded) return;

                    const { scrollTop, scrollHeight, clientHeight } = threatsPanel;

                    // Trigger when 100px from bottom
                    if (scrollTop + clientHeight >= scrollHeight - 100) {
                        isLoadingThreats = true;
                        threatPage++;
                        console.log(`üìú Loading more threats (page ${threatPage})`);

                        loadThreats(true).then(() => {
                            isLoadingThreats = false;
                        });
                    }
                });
            }

            // Networks panel infinite scroll
            const networksPanel = document.querySelector('#networks-panel .panel-content');
            if (networksPanel) {
                let isLoadingNetworks = false;

                networksPanel.addEventListener('scroll', () => {
                    if (isLoadingNetworks || !window.networkTable) return;

                    const { scrollTop, scrollHeight, clientHeight } = networksPanel;

                    // Trigger when 100px from bottom (smaller trigger for abbreviated mode)
                    if (scrollTop + clientHeight >= scrollHeight - 100) {
                        if (networkTable.hasMore()) {
                            isLoadingNetworks = true;
                            console.log(`üìú Loading more networks (${networkTable.displayedCount}/${networkTable.getSortedNetworks().length})`);

                            networkTable.loadMore();
                            renderNetworkTable('networks-table', (network) => {
                                console.log(`üì° Network selected: ${network.ssid || 'Hidden'} (${network.bssid})`);
                                loadObservationsToMap(network.bssid, network.ssid);

                                // Highlight selected row
                                document.querySelectorAll('#networks-table tbody tr').forEach(r => {
                                    r.style.background = '';
                                });
                                const selectedRow = document.querySelector(`#networks-table tbody tr[data-bssid="${network.bssid}"]`);
                                if (selectedRow) {
                                    selectedRow.style.background = 'rgba(59, 130, 246, 0.2)';
                                }
                            }, true); // append = true

                            setTimeout(() => { isLoadingNetworks = false; }, 100);
                        }
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            highlightActiveNav();
            setTimeout(() => initMap(), 100);
            loadThreats();
            loadNetworks();
            checkURLParameters();
            setupInfiniteScroll();
        });

        document.getElementById('refresh-btn').addEventListener('click', () => {
            loadThreats();
            loadNetworks();
            // Don't reload map points - user selects threat
        });

        // Wire up filter controls
        document.addEventListener('DOMContentLoaded', () => {
            // Network search with debounce
            const networkSearch = document.getElementById('network-search');
            let networkSearchTimeout;
            if (networkSearch && window.networkTable) {
                networkSearch.addEventListener('input', (e) => {
                    clearTimeout(networkSearchTimeout);
                    networkSearchTimeout = setTimeout(() => {
                        networkTable.applySearch(e.target.value);
                        renderNetworkTable('networks-table', (network) => {
                            loadObservationsToMap(network.bssid, network.ssid);
                        });
                    }, 300);
                });
            }

            // Network type filter
            const networkTypeFilter = document.getElementById('network-type-filter');
            if (networkTypeFilter) {
                networkTypeFilter.addEventListener('change', (e) => {
                    // Filter logic will be added in next iteration
                    console.log('Network type filter:', e.target.value);
                });
            }

            // Network security filter
            const networkSecurityFilter = document.getElementById('network-security-filter');
            if (networkSecurityFilter) {
                networkSecurityFilter.addEventListener('change', (e) => {
                    // Filter logic will be added in next iteration
                    console.log('Network security filter:', e.target.value);
                });
            }

            // Threat search
            const threatSearch = document.getElementById('threat-search');
            if (threatSearch) {
                threatSearch.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    const threats = document.querySelectorAll('.threat-row');
                    threats.forEach(threat => {
                        const text = threat.textContent.toLowerCase();
                        threat.style.display = text.includes(searchTerm) ? '' : 'none';
                    });
                });
            }

            // Threat severity filter
            const threatSeverityFilter = document.getElementById('threat-severity-filter');
            if (threatSeverityFilter) {
                threatSeverityFilter.addEventListener('change', (e) => {
                    minThreatSeverity = e.target.value;
                    console.log(`üéöÔ∏è Threat severity filter changed to: ${minThreatSeverity}`);
                    loadThreats(false); // Reload threats with new filter
                });
            }

            // Threat type filter
            const threatTypeFilter = document.getElementById('threat-type-filter');
            if (threatTypeFilter) {
                threatTypeFilter.addEventListener('change', (e) => {
                    selectedThreatType = e.target.value;
                    console.log('üéöÔ∏è Threat type filter changed to:', selectedThreatType || 'all');
                    loadThreats();
                });
            }

            // Layout toggle functionality
            const mainGrid = document.getElementById('main-grid');
            const layoutButtons = {
                'layout-side': 'layout-side-by-side',
                'layout-vertical': 'layout-vertical',
                'layout-map': 'layout-map-focus'
            };

            // Load saved layout preference
            const savedLayout = localStorage.getItem('geospatial-layout') || 'layout-side-by-side';
            mainGrid.className = `main ${savedLayout}`;
            Object.keys(layoutButtons).forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (layoutButtons[btnId] === savedLayout) {
                    btn.classList.add('active');
                }
            });

            // Add click handlers for layout buttons
            Object.keys(layoutButtons).forEach(btnId => {
                document.getElementById(btnId).addEventListener('click', () => {
                    const layoutClass = layoutButtons[btnId];
                    mainGrid.className = `main ${layoutClass}`;
                    localStorage.setItem('geospatial-layout', layoutClass);
                    
                    // Update active button
                    Object.keys(layoutButtons).forEach(id => {
                        document.getElementById(id).classList.remove('active');
                    });
                    document.getElementById(btnId).classList.add('active');
                    
                    // Resize map after layout change
                    setTimeout(() => {
                        if (map) map.resize();
                    }, 350);
                });
            });

            // Network row click handler - render on map
            function handleNetworkRowClick(network) {
                if (!network.location || !network.location.lat || !network.location.lng) {
                    console.log('Network has no location data');
                    return;
                }

                // Center map on network location
                map.flyTo({
                    center: [network.location.lng, network.location.lat],
                    zoom: 16,
                    duration: 1000
                });

                // Add or update marker for this network
                const markerId = `selected-${network.bssid}`;
                
                // Remove previous selected marker
                if (map.getLayer(markerId)) {
                    map.removeLayer(markerId);
                    map.removeSource(markerId);
                }

                // Add new marker
                map.addSource(markerId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [network.location.lng, network.location.lat]
                        },
                        properties: {
                            bssid: network.bssid,
                            ssid: network.ssid || 'Hidden',
                            type: network.type
                        }
                    }
                });

                map.addLayer({
                    id: markerId,
                    type: 'circle',
                    source: markerId,
                    paint: {
                        'circle-radius': 12,
                        'circle-color': '#3b82f6',
                        'circle-stroke-width': 3,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.8
                    }
                });

                // Show popup
                new mapboxgl.Popup()
                    .setLngLat([network.location.lng, network.location.lat])
                    .setHTML(`
                        <div style="color: #1e293b; font-size: 12px;">
                            <strong>${network.ssid || 'Hidden Network'}</strong><br>
                            ${network.bssid}<br>
                            Type: ${network.type} | Signal: ${network.signal || 'N/A'} dBm
                        </div>
                    `)
                    .addTo(map);
            }
        });
    </script>
</body>
</html>