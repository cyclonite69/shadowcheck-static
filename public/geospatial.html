<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ShadowCheck - Geospatial</title>
    <link rel="icon" type="image/svg+xml" href="/favicon.svg">
    <script src="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.js"></script>
    <link href="https://api.mapbox.com/mapbox-gl-js/v3.8.0/mapbox-gl.css" rel="stylesheet">
    <link rel="stylesheet" href="/assets/styles/unified.css">
    <style>
        .app-main { display: grid; grid-template-columns: 2fr 1fr; gap: 12px; }
        .panel { display: flex; flex-direction: column; min-height: 0; }
        .panel-content { flex: 1; overflow: auto; padding: 0; }
        #map { width: 100%; height: 100%; }
        
        /* Tooltip Styles */
        .dark-tooltip-popup .mapboxgl-popup-content {
            background: rgba(15, 23, 42, 0.95) !important;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 8px;
            padding: 0 !important;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.5);
        }
        
        .dark-tooltip {
            background: transparent;
            color: #f8fafc;
            padding: 12px;
            font-size: 13px;
            line-height: 1.5;
        }
        
        .tooltip-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
            padding-bottom: 8px;
            border-bottom: 1px solid rgba(148, 163, 184, 0.2);
        }
        
        .tooltip-ssid {
            font-weight: 600;
            font-size: 14px;
            color: #22d3ee;
        }
        
        .tooltip-field {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            gap: 12px;
        }
        
        .tooltip-label {
            color: #94a3b8;
            font-size: 12px;
        }
        
        .tooltip-value {
            color: #f8fafc;
            font-weight: 500;
        }
        
        .tooltip-value.mono {
            font-family: 'Courier New', monospace;
            font-size: 11px;
        }
        
        .tooltip-value.signal-strong { color: #22c55e; }
        .tooltip-value.signal-medium { color: #eab308; }
        .tooltip-value.signal-weak { color: #ef4444; }
        
        .tooltip-timestamp {
            margin-top: 8px;
            padding-top: 8px;
            border-top: 1px solid rgba(148, 163, 184, 0.2);
            display: flex;
            justify-content: space-between;
            font-size: 11px;
        }
        
        .tooltip-icon {
            opacity: 0.7;
        }
    </style>
</head>
<body data-page="geospatial">
    <div class="app-container">
        <header class="app-header">
            <div class="header-left">
                <div class="logo">SC</div>
                <span class="font-semibold">ShadowCheck</span>
            </div>
            <nav class="nav-links">
                <a href="/" class="nav-link">Dashboard</a>
                <a href="/networks.html" class="nav-link">Networks</a>
                <a href="/geospatial.html" class="nav-link active">Geospatial</a>
                <a href="/surveillance.html" class="nav-link">Surveillance</a>
                <a href="/analytics.html" class="nav-link">Analytics</a>
                <a href="/admin.html" class="nav-link">Admin</a>
            </nav>
            <div class="header-right">
                <button class="btn btn-sm" onclick="window.baseComponents?.showCardLibrary()">‚ûï Add Card</button>
                <button class="btn btn-sm" onclick="window.baseComponents?.toggleSnap(this)">üî≤ Snap: ON</button>
                <button class="btn btn-sm" onclick="window.baseComponents?.resetLayout()">‚Ü∫ Reset</button>
                <button class="btn btn-sm" onclick="location.reload()">üîÑ Refresh</button>
                <div class="status-indicator">
                    <div class="status-dot"></div>
                    <span>Online</span>
                </div>
            </div>
        </header>

        <main class="app-main">
            <!-- MAP PANEL -->
            <div class="panel" id="map-panel">
                <div class="panel-header">
                    <span>üìç Network Distribution Map</span>
                    <div style="display: flex; gap: 8px; align-items: center;">
                        <select id="map-style-selector" onchange="changeMapStyle(this.value)" style="padding: 4px 8px; font-size: 11px; background: rgba(30, 41, 59, 0.9); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                            <option value="mapbox://styles/mapbox/standard">Standard</option>
                            <option value="mapbox://styles/mapbox/streets-v12">Streets</option>
                            <option value="mapbox://styles/mapbox/outdoors-v12">Outdoors</option>
                            <option value="mapbox://styles/mapbox/light-v11">Light</option>
                            <option value="mapbox://styles/mapbox/dark-v11">Dark</option>
                            <option value="mapbox://styles/mapbox/satellite-v9">Satellite</option>
                            <option value="mapbox://styles/mapbox/satellite-streets-v12">Satellite Streets</option>
                            <option value="mapbox://styles/mapbox/navigation-day-v1">Navigation Day</option>
                            <option value="mapbox://styles/mapbox/navigation-night-v1">Navigation Night</option>
                        </select>
                        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer;">
                            <input type="checkbox" id="toggle-3d-buildings" onchange="toggle3DBuildings(this.checked)">
                            <span>üè¢ 3D Buildings</span>
                        </label>
                        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px; cursor: pointer;">
                            <input type="checkbox" id="toggle-terrain" onchange="toggleTerrain(this.checked)">
                            <span>‚õ∞Ô∏è Terrain</span>
                        </label>
                        <button onclick="centerOnHome()" class="btn btn-sm" title="Center on home location">üè† Home</button>
                        <button onclick="centerOnCurrentLocation()" class="btn btn-sm" title="Center on your current GPS location">üìç GPS</button>
                        <button onclick="fitBounds()" class="btn btn-sm" title="Fit all networks in view">üéØ Fit All</button>
                        <label style="display: flex; align-items: center; gap: 4px; font-size: 11px;">
                            <span>‚≠ï Radius:</span>
                            <input type="number" id="home-radius" value="0" min="0" max="10000" step="50" onchange="updateHomeCircle(this.value)" style="width: 70px; padding: 4px 6px; font-size: 11px; background: rgba(30, 41, 59, 0.9); border: 1px solid rgba(148, 163, 184, 0.2); color: #f8fafc; border-radius: 4px;">
                            <span>m</span>
                        </label>
                    </div>
                </div>
                <div class="panel-content">
                    <div id="map"></div>
                </div>
            </div>

            <!-- THREATS PANEL -->
            <div class="panel" id="threats-panel">
                <div class="panel-header">
                    <span>‚ö†Ô∏è Active Threats <span class="panel-count" id="threats-count">0</span></span>
                    <div style="display: flex; gap: 6px; flex: 1; max-width: 700px;">
                        <input type="text" id="threat-search" placeholder="Search threats..." style="flex: 1; min-width: 120px; padding: 4px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #e0e7ff; border-radius: 4px;">
                        <select id="threat-severity-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="all">All Severity</option>
                            <option value="critical">Critical (80+)</option>
                            <option value="high">High (70-79)</option>
                            <option value="medium">Medium (50-69)</option>
                            <option value="low">Low (30-49)</option>
                        </select>
                        <select id="threat-type-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="">All Types</option>
                            <option value="W">WiFi</option>
                            <option value="E">BLE</option>
                            <option value="B">Bluetooth</option>
                        </select>
                    </div>
                </div>
                <div class="panel-content">
                    <div class="threat-list" id="threat-list">
                        <div class="loading">Loading threats...</div>
                    </div>
                </div>
            </div>

            <!-- NETWORKS PANEL -->
            <div class="panel" id="networks-panel">
                <div class="panel-header">
                    <span>üì° Recent Networks <span class="panel-count" id="networks-count">0</span></span>
                    <div style="display: flex; gap: 6px; flex: 1; max-width: 700px;">
                        <input type="text" id="network-search" placeholder="Search SSID/BSSID..." style="flex: 1; min-width: 120px; padding: 4px 8px; font-size: 11px; background: rgba(15, 23, 42, 0.6); border: 1px solid rgba(148, 163, 184, 0.2); color: #e0e7ff; border-radius: 4px;">
                        <select id="network-type-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="">All Types</option>
                            <option value="W">WiFi</option>
                            <option value="E">BLE</option>
                            <option value="B">Bluetooth</option>
                        </select>
                        <select id="network-security-filter" style="padding: 4px 8px; font-size: 11px;">
                            <option value="">All Security</option>
                            <option value="OPEN">Open</option>
                            <option value="WEP">WEP</option>
                            <option value="WPA">WPA/WPA2</option>
                            <option value="WPA3">WPA3</option>
                        </select>
                    </div>
                </div>
                <div class="panel-content">
                    <table class="network-table" id="networks-table">
                        <thead>
                            <!-- Headers generated dynamically by renderNetworkTable() -->
                        </thead>
                        <tbody>
                            <tr>
                                <td colspan="4" class="loading">Loading networks...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <script>
        // HTML escaping utility to prevent XSS
        function escapeHtml(text) {
            if (text === null || text === undefined) return '';
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Use dynamic API base URL based on current window location
        const API_BASE = Object.freeze(`${window.location.protocol}//${window.location.hostname}:3001/api`);
        let map = null;

        // Advanced Network Table Configuration
        const NETWORK_COLUMNS = {
            type: {
                label: 'Type',
                width: '60px',
                sortable: true,
                default: true,
                format: (val) => {
                    const typeMap = {
                        'W': 'WiFi',
                        'E': 'BLE',
                        'B': 'BT',
                        'L': 'LTE',
                        'N': '5G NR',
                        'G': 'GSM'
                    };
                    return typeMap[val] || 'WiFi';
                }
            },
            ssid: {
                label: 'SSID',
                width: '150px',
                sortable: true,
                default: true,
                format: (val) => val || '(hidden)'
            },
            bssid: {
                label: 'BSSID',
                width: '120px',
                sortable: true,
                default: true,
                monospace: true,
                format: (val) => val || 'N/A'
            },
            signal: {
                label: 'Signal (dBm)',
                width: '100px',
                sortable: true,
                default: true,
                format: (val) => val !== null && val !== undefined ? `${val} dBm` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : -999
            },
            security: {
                label: 'Security',
                width: '140px',
                sortable: true,
                default: true,
                format: (val) => val || 'Unknown'
            },
            frequency: {
                label: 'Frequency (GHz)',
                width: '120px',
                sortable: true,
                default: false,
                format: (val) => val ? `${val} GHz` : 'N/A',
                sortValue: (val) => val ? parseFloat(val) : 0
            },
            channel: {
                label: 'Channel',
                width: '80px',
                sortable: true,
                default: false,
                format: (val) => val || 'N/A'
            },
            observations: {
                label: 'Observations',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val || '1',
                sortValue: (val) => val ? parseInt(val) : 1
            },
            latitude: {
                label: 'Latitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            longitude: {
                label: 'Longitude',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? parseFloat(val).toFixed(6) : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            distanceFromHome: {
                label: 'Distance (km)',
                width: '110px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(2)} km` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 999999
            },
            accuracy: {
                label: 'Accuracy (m)',
                width: '100px',
                sortable: true,
                default: false,
                format: (val) => val !== null && val !== undefined ? `${parseFloat(val).toFixed(1)} m` : 'N/A',
                sortValue: (val) => val !== null && val !== undefined ? parseFloat(val) : 0
            },
            timestamp: {
                label: 'Last Seen',
                width: '160px',
                sortable: true,
                default: true,
                format: (val) => {
                    if (!val) return 'Unknown';
                    try {
                        const date = typeof val === 'number' ? new Date(val) : new Date(val);
                        return date.toLocaleString();
                    } catch (e) {
                        return 'Unknown';
                    }
                },
                sortValue: (val) => {
                    if (!val) return 0;
                    return typeof val === 'number' ? val : new Date(val).getTime();
                }
            },
            misc: {
                label: 'Misc',
                width: '200px',
                sortable: false,
                default: false,
                format: (val) => val || ''
            }
        };

        // Network Table State Management
        class NetworkTableManager {
            constructor(pageId, abbreviatedMode = false) {
                this.pageId = pageId;
                this.abbreviatedMode = abbreviatedMode;
                this.storageKey = `networkListColumns-${pageId}`;
                this.networks = [];
                this.filteredNetworks = [];
                this.currentSort = { column: null, direction: null };
                this.visibleColumns = this.loadColumnPreferences();
                this.searchTerm = '';
                this.displayedCount = 0;
                this.batchSize = abbreviatedMode ? 20 : 50; // Smaller batch for abbreviated mode
            }

            // Load column visibility preferences from localStorage
            loadColumnPreferences() {
                const saved = localStorage.getItem(this.storageKey);
                if (saved) {
                    try {
                        return JSON.parse(saved);
                    } catch (e) {
                        console.error('Error loading column preferences:', e);
                    }
                }
                // Return default columns
                return Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
            }

            // Save column visibility preferences to localStorage
            saveColumnPreferences() {
                localStorage.setItem(this.storageKey, JSON.stringify(this.visibleColumns));
            }

            // Reset to default columns
            resetToDefaults() {
                this.visibleColumns = Object.keys(NETWORK_COLUMNS).filter(col => NETWORK_COLUMNS[col].default);
                this.saveColumnPreferences();
            }

            // Toggle column visibility
            toggleColumn(columnKey) {
                const index = this.visibleColumns.indexOf(columnKey);
                if (index > -1) {
                    this.visibleColumns.splice(index, 1);
                } else {
                    this.visibleColumns.push(columnKey);
                }
                this.saveColumnPreferences();
            }

            // Set sort column
            setSort(column) {
                if (!NETWORK_COLUMNS[column] || !NETWORK_COLUMNS[column].sortable) return;

                if (this.currentSort.column === column) {
                    // Cycle through: asc -> desc -> null
                    if (this.currentSort.direction === 'asc') {
                        this.currentSort.direction = 'desc';
                    } else if (this.currentSort.direction === 'desc') {
                        this.currentSort = { column: null, direction: null };
                    }
                } else {
                    this.currentSort = { column, direction: 'asc' };
                }
            }

            // Apply search filter
            setSearch(term) {
                this.searchTerm = term.toLowerCase();
                this.applyFilters();
            }

            // Apply filters (search)
            applyFilters() {
                if (!this.searchTerm) {
                    this.filteredNetworks = [...this.networks];
                } else {
                    this.filteredNetworks = this.networks.filter(net => {
                        const ssid = (net.ssid || '').toLowerCase();
                        const bssid = (net.bssid || '').toLowerCase();
                        return ssid.includes(this.searchTerm) || bssid.includes(this.searchTerm);
                    });
                }
                this.displayedCount = 0; // Reset on filter change
            }

            // Load more networks (for infinite scroll)
            loadMore() {
                this.displayedCount += this.batchSize;
            }

            // Check if more networks available
            hasMore() {
                const sorted = this.getSortedNetworks();
                return this.displayedCount < sorted.length;
            }

            // Get sorted networks
            getSortedNetworks() {
                let sorted = [...this.filteredNetworks];

                if (this.currentSort.column) {
                    const col = NETWORK_COLUMNS[this.currentSort.column];
                    const direction = this.currentSort.direction === 'asc' ? 1 : -1;

                    sorted.sort((a, b) => {
                        let aVal = a[this.currentSort.column];
                        let bVal = b[this.currentSort.column];

                        // Use sortValue function if available
                        if (col.sortValue) {
                            aVal = col.sortValue(aVal);
                            bVal = col.sortValue(bVal);
                        }

                        // Handle null/undefined
                        if (aVal === null || aVal === undefined) return direction;
                        if (bVal === null || bVal === undefined) return -direction;

                        // Numeric comparison
                        if (typeof aVal === 'number' && typeof bVal === 'number') {
                            return (aVal - bVal) * direction;
                        }

                        // String comparison (case-insensitive)
                        const aStr = String(aVal).toLowerCase();
                        const bStr = String(bVal).toLowerCase();
                        return aStr.localeCompare(bStr) * direction;
                    });
                }

                return sorted;
            }

            // Set networks data
            setNetworks(networks) {
                this.networks = networks;
                this.applyFilters();
            }

            // Render column selector UI
            renderColumnSelector(containerId) {
                const container = document.getElementById(containerId);
                if (!container) return;

                const html = `
                    <div class="column-selector">
                        <button class="column-selector-btn" onclick="toggleColumnSelectorDropdown()">
                            ‚öôÔ∏è Columns
                        </button>
                        <div class="column-selector-dropdown" id="column-selector-dropdown" style="display: none;">
                            <div class="column-selector-header">
                                <span>Show/Hide Columns</span>
                                <button onclick="networkTable.resetToDefaults(); renderNetworkTable();" class="reset-btn">Reset</button>
                            </div>
                            <div class="column-selector-list">
                                ${Object.keys(NETWORK_COLUMNS).map(key => `
                                    <label class="column-selector-item">
                                        <input
                                            type="checkbox"
                                            ${this.visibleColumns.includes(key) ? 'checked' : ''}
                                            onchange="networkTable.toggleColumn('${key}'); renderNetworkTable();"
                                        />
                                        <span>${NETWORK_COLUMNS[key].label}</span>
                                    </label>
                                `).join('')}
                            </div>
                        </div>
                    </div>
                `;

                container.innerHTML = html;
            }
        }

        // Toggle column selector dropdown
        function toggleColumnSelectorDropdown() {
            const dropdown = document.getElementById('column-selector-dropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
            const dropdown = document.getElementById('column-selector-dropdown');
            const btn = document.querySelector('.column-selector-btn');
            if (dropdown && btn && !dropdown.contains(e.target) && !btn.contains(e.target)) {
                dropdown.style.display = 'none';
            }
        });

        // Render network table with current settings
        function renderNetworkTable(tableId = 'networks-table', onRowClick = null, append = false) {
            if (!window.networkTable) return;

            const table = document.getElementById(tableId);
            if (!table) return;

            const tbody = table.querySelector('tbody');
            const thead = table.querySelector('thead');
            if (!tbody || !thead) return;

            // Get sorted networks
            const allNetworks = networkTable.getSortedNetworks();

            // Render table headers (unless appending)
            if (!append) {
                const headerRow = document.createElement('tr');
                networkTable.visibleColumns.forEach(colKey => {
                    const col = NETWORK_COLUMNS[colKey];
                    const th = document.createElement('th');
                    th.style.width = col.width;
                    th.textContent = col.label;

                    if (col.sortable) {
                        th.className = 'sortable';
                        th.onclick = () => {
                            networkTable.setSort(colKey);
                            renderNetworkTable(tableId, onRowClick);
                        };

                        // Add sort indicator
                        const indicator = document.createElement('span');
                        indicator.className = 'sort-indicator';
                        if (networkTable.currentSort.column === colKey) {
                            th.classList.add('sorted');
                            indicator.textContent = networkTable.currentSort.direction === 'asc' ? '‚ñ≤' : '‚ñº';
                        } else {
                            indicator.textContent = '‚ñ≤';
                        }
                        th.appendChild(indicator);
                    }

                    headerRow.appendChild(th);
                });
                thead.innerHTML = '';
                thead.appendChild(headerRow);
            }

            // Clear body if not appending
            if (!append) {
                tbody.innerHTML = '';
                networkTable.displayedCount = 0;
            }

            // Check if empty
            if (allNetworks.length === 0 && !append) {
                const tr = document.createElement('tr');
                const td = document.createElement('td');
                td.colSpan = networkTable.visibleColumns.length;
                td.className = 'loading';
                td.textContent = networkTable.searchTerm ? 'No networks found matching search' : 'No networks found';
                tr.appendChild(td);
                tbody.appendChild(tr);
                return;
            }

            // Get the batch to render
            const startIdx = networkTable.displayedCount;
            const endIdx = Math.min(startIdx + networkTable.batchSize, allNetworks.length);
            const networksToRender = allNetworks.slice(startIdx, endIdx);

            // Render networks
            networksToRender.forEach(network => {
                const tr = document.createElement('tr');
                tr.dataset.bssid = network.bssid;

                // Add click handler if provided
                if (onRowClick) {
                    tr.style.cursor = 'pointer';
                    tr.onclick = () => onRowClick(network);
                }

                networkTable.visibleColumns.forEach(colKey => {
                    const col = NETWORK_COLUMNS[colKey];
                    const td = document.createElement('td');

                    // Get value from network data
                    let value = network[colKey];

                    // Special handling for latitude/longitude from location object
                    if (colKey === 'latitude' && network.location) {
                        value = network.location.lat;
                    } else if (colKey === 'longitude' && network.location) {
                        value = network.location.lng;
                    }

                    // Format value
                    td.textContent = col.format ? col.format(value) : (value || 'N/A');

                    // Apply monospace style if needed
                    if (col.monospace) {
                        td.className = 'mono';
                    }

                    tr.appendChild(td);
                });

                tbody.appendChild(tr);
            });

            // Update displayed count
            networkTable.displayedCount = endIdx;

            // Update count display
            updateNetworkCount();
        }

        // Update network count display
        function updateNetworkCount() {
            const countEl = document.getElementById('networks-count');
            if (countEl && window.networkTable) {
                const total = networkTable.networks.length;
                const filtered = networkTable.filteredNetworks.length;
                if (networkTable.searchTerm) {
                    countEl.textContent = `${filtered} / ${total}`;
                } else {
                    countEl.textContent = total;
                }
            }
        }

        // Parse security/encryption from capabilities
        function parseSecurityType(capabilities, encryption) {
            if (!capabilities && !encryption) return 'OPEN';

            const caps = (capabilities || '').toUpperCase();
            const enc = (encryption || '').toLowerCase();

            // Check for WPA3
            if (caps.includes('WPA3') || caps.includes('SAE')) {
                if (caps.includes('EAP') || caps.includes('MGT')) return 'WPA3-E';
                return 'WPA3-P';
            }

            // Check for WPA2
            if (caps.includes('WPA2') || caps.includes('RSN')) {
                if (caps.includes('EAP') || caps.includes('MGT')) return 'WPA2-E';
                return 'WPA2-P';
            }

            // Check for WPA (original)
            if (caps.includes('WPA-') && !caps.includes('WPA2')) {
                return 'WPA';
            }

            // Check for WEP
            if (caps.includes('WEP') || enc === 'wep') {
                return 'WEP';
            }

            // Check for WPS only
            if (caps.includes('WPS') && !caps.includes('WPA')) {
                return 'WPS';
            }

            // If we have encryption field
            if (enc === 'wpa3') return 'WPA3-P';
            if (enc === 'wpa2') return 'WPA2-P';
            if (enc === 'wpa') return 'WPA';
            if (enc === 'wep') return 'WEP';

            // Default
            return caps ? 'Unknown' : 'OPEN';
        }

        // Map type codes to readable names
        function getNetworkTypeName(typeCode) {
            const typeMap = {
                'W': 'WiFi',
                'E': 'BLE',
                'B': 'Bluetooth',
                'L': 'LTE',
                'N': '5G NR',
                'G': 'GSM'
            };
            return typeMap[typeCode] || typeCode || 'Unknown';
        }

        // Get network type icon SVG
        function getNetworkIcon(networkType) {
            const type = (networkType || 'wifi').toLowerCase();

            // Bluetooth icon
            if (type.includes('ble') || type.includes('bluetooth') || type === 'b' || type === 'e') {
                return `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                    <path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z"/>
                </svg>`;
            }

            // Cellular/signal tower icon
            if (type.includes('cellular') || type.includes('cell') || type.includes('gsm') || type.includes('lte') || type.includes('5g') || type === 'g' || type === 'l' || type === 'n') {
                return `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                    <path d="M17.77 3.77L16 2 6 12l10 10 1.77-1.77L9.54 12z"/>
                    <path d="M6 12l10-10 1.77 1.77L9.54 12l8.23 8.23L16 22z"/>
                    <path d="M6 12l5-5v10z"/>
                </svg>`;
            }

            // WiFi icon (default)
            return `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                <path d="M12 18.5a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3z"/>
                <path d="M12 14c-1.7 0-3.3.6-4.6 1.8a1 1 0 1 0 1.4 1.4A5 5 0 0 1 12 16a5 5 0 0 1 3.2 1.2 1 1 0 1 0 1.3-1.5A6.9 6.9 0 0 0 12 14z"/>
                <path d="M12 9.5c-3 0-5.8 1.1-8 3.2a1 1 0 1 0 1.4 1.4c1.8-1.8 4.1-2.7 6.6-2.7 2.5 0 4.8.9 6.6 2.7a1 1 0 1 0 1.4-1.4c-2.2-2.1-5.1-3.2-8-3.2z"/>
                <path d="M12 5c-4.3 0-8.3 1.6-11.3 4.6a1 1 0 1 0 1.4 1.4C4.6 7.5 8.2 6 12 6s7.4 1.5 9.9 4a1 1 0 1 0 1.4-1.4C20.3 6.6 16.3 5 12 5z"/>
            </svg>`;
        }

        // Generate Network Click Tooltip HTML
        function generateNetworkTooltip(props, coordinates, manufacturer, timestamp) {
            // Observation count (if available)
            let observationInfo = '';
            if (props.observationIndex && props.totalObservations) {
                observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
            }

            // Get network icon
            const iconSvg = getNetworkIcon(props.type);

            // Signal strength with color class
            const signal = props.signal || 'N/A';
            let signalClass = '';
            if (signal !== 'N/A') {
                if (signal >= -50) signalClass = 'signal-strong';
                else if (signal >= -70) signalClass = 'signal-medium';
                else signalClass = 'signal-weak';
            }

            // Distance from home
            let distanceFromHome = '';
            if (props.distanceFromHome) {
                distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
            }

            // Build tooltip HTML
            return `
                <div class="dark-tooltip">
                    ${observationInfo}
                    <div class="tooltip-header">
                        <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                        ${iconSvg}
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">BSSID:</span>
                        <span class="tooltip-value mono">${props.bssid}</span>
                    </div>
                    ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Signal:</span>
                        <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">Security:</span>
                        <span class="tooltip-value">${props.security || 'Unknown'}</span>
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">Type:</span>
                        <span class="tooltip-value">${props.typeDisplay || getNetworkTypeName(props.type)}</span>
                    </div>
                    ${distanceFromHome}
                    <div class="tooltip-timestamp">
                        <span class="tooltip-label">Last seen:</span>
                        <span class="tooltip-value">${timestamp}</span>
                    </div>
                </div>
            `;
        }

        // Generate Observation Point Click Tooltip HTML
        function generateObservationClickTooltip(props, coordinates, manufacturer, seenBy, time) {
            // Observation sequence header
            const observationHeader = `<div class="observation-header">Observation #${props.sequence} of ${props.total}</div>`;

            // Get network icon
            const iconSvg = getNetworkIcon(props.type);

            // Signal strength with color class
            const signal = props.signal || 'N/A';
            let signalClass = '';
            if (signal !== 'N/A') {
                if (signal >= -50) signalClass = 'signal-strong';
                else if (signal >= -70) signalClass = 'signal-medium';
                else signalClass = 'signal-weak';
            }

            // Altitude (if exists)
            let altitudeField = '';
            if (props.altitude !== undefined && props.altitude !== null) {
                altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
            }

            // Accuracy (if exists)
            let accuracyField = '';
            if (props.accuracy !== undefined && props.accuracy !== null) {
                accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
            }

            // Distance from home (required)
            const distanceFromHome = props.distance_from_home !== undefined
                ? parseFloat(props.distance_from_home).toFixed(2)
                : '0.00';

            // Seen by (optional)
            let seenByField = '';
            if (seenBy) {
                seenByField = `<div class="tooltip-field"><span class="tooltip-label">Seen by:</span><span class="tooltip-value">${seenBy}</span></div>`;
            }

            // Build tooltip HTML
            return `
                <div class="dark-tooltip">
                    ${observationHeader}
                    <div class="tooltip-header">
                        <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                        ${iconSvg}
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">BSSID:</span>
                        <span class="tooltip-value mono">${props.bssid}</span>
                    </div>
                    ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Signal:</span>
                        <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                    </div>
                    ${altitudeField}
                    ${accuracyField}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Distance from Home:</span>
                        <span class="tooltip-value">${distanceFromHome} km</span>
                    </div>
                    ${seenByField}
                    <div class="tooltip-timestamp">
                        <span class="tooltip-label">Time:</span>
                        <span class="tooltip-value">${time}</span>
                    </div>
                </div>
            `;
        }

        // Generate Observation Point Hover Tooltip HTML (includes range radius)
        function generateObservationHoverTooltip(props, coordinates, manufacturer, hoverSeenBy, time, radiusMeters) {
            // Observation sequence header
            const observationHeader = `<div class="observation-header">Observation #${props.sequence} of ${props.total}</div>`;

            // Get network icon
            const iconSvg = getNetworkIcon(props.type);

            // Signal strength with color class
            const signal = props.signal || 'N/A';
            let signalClass = '';
            if (signal !== 'N/A') {
                if (signal >= -50) signalClass = 'signal-strong';
                else if (signal >= -70) signalClass = 'signal-medium';
                else signalClass = 'signal-weak';
            }

            // Altitude (if exists)
            let altitudeField = '';
            if (props.altitude !== undefined && props.altitude !== null) {
                altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
            }

            // Accuracy (if exists)
            let accuracyField = '';
            if (props.accuracy !== undefined && props.accuracy !== null) {
                accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
            }

            // Distance from home (required)
            const distanceFromHome = props.distance_from_home !== undefined
                ? parseFloat(props.distance_from_home).toFixed(2)
                : '0.00';

            // Range radius field (HOVER ONLY)
            let rangeField = '';
            if (radiusMeters !== undefined && radiusMeters !== null) {
                rangeField = `<div class="tooltip-field"><span class="tooltip-label">Range:</span><span class="tooltip-value">${radiusMeters}m radius</span></div>`;
            }

            // Seen by (optional)
            let seenByField = '';
            if (hoverSeenBy) {
                seenByField = `<div class="tooltip-field"><span class="tooltip-label">Seen by:</span><span class="tooltip-value">${hoverSeenBy}</span></div>`;
            }

            // Build tooltip HTML
            return `
                <div class="dark-tooltip">
                    ${observationHeader}
                    <div class="tooltip-header">
                        <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                        ${iconSvg}
                    </div>
                    <div class="tooltip-field">
                        <span class="tooltip-label">BSSID:</span>
                        <span class="tooltip-value mono">${props.bssid}</span>
                    </div>
                    ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Signal:</span>
                        <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                    </div>
                    ${altitudeField}
                    ${accuracyField}
                    <div class="tooltip-field">
                        <span class="tooltip-label">Distance from Home:</span>
                        <span class="tooltip-value">${distanceFromHome} km</span>
                    </div>
                    ${rangeField}
                    ${seenByField}
                    <div class="tooltip-timestamp">
                        <span class="tooltip-label">Time:</span>
                        <span class="tooltip-value">${time}</span>
                    </div>
                </div>
            `;
        }

        // Manufacturer lookup from BSSID (OUI-based)
        async function getManufacturerFromBSSID(bssid) {
            if (!bssid) return null;

            // Try API first for complete database
            try {
                const response = await fetch(`${API_BASE_URL}/api/manufacturer/${bssid}`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.manufacturer) return data.manufacturer;
                }
            } catch (err) {
                console.warn('API manufacturer lookup failed, using local map');
            }

            // Fallback to local OUI map
            const oui = bssid.substring(0, 8).toUpperCase().replace(/:/g, '');

            // Common manufacturers (simplified lookup)
            const ouiMap = {
                '00037F': 'Atheros',
                '000393': 'Apple',
                '000502': 'Apple',
                '000D93': 'Apple',
                '001124': 'Apple',
                '0016CB': 'Apple',
                '001B63': 'Apple',
                '001EC2': 'Apple',
                '0021E9': 'Apple',
                '002312': 'Apple',
                '002490': 'Apple',
                '0025BC': 'Apple',
                '003065': 'Apple',
                '0050E4': 'Apple',
                '00A040': 'Apple',
                '00F4B9': 'Apple',
                '04489A': 'Apple',
                '0C7132': 'Apple',
                '10417F': 'Apple',
                '101C0C': 'Apple',
                '1C36BB': 'Apple',
                '28E02C': 'Apple',
                '28E14C': 'Apple',
                '34159E': 'Apple',
                '34AB37': 'Apple',
                '3C0754': 'Apple',
                '50EAD6': 'Apple',
                '5C5948': 'Apple',
                '5CF938': 'Apple',
                '680927': 'Apple',
                '68967B': 'Apple',
                '6C94F8': 'Apple',
                '70CD60': 'Apple',
                '78A3E4': 'Apple',
                '7C04D0': 'Apple',
                '7CD1C3': 'Apple',
                '8C5877': 'Apple',
                '90B21F': 'Apple',
                '9C207B': 'Apple',
                'A4C361': 'Apple',
                'B019C6': 'Apple',
                'B853AC': 'Apple',
                'C82A14': 'Apple',
                'D023DB': 'Apple',
                'D4F46F': 'Apple',
                'DC2B2A': 'Apple',
                'E0F847': 'Apple',
                'F0D1A9': 'Apple',
                'F82793': 'Apple',
                '001D7E': 'Motorola',
                '000C41': 'Motorola',
                '000E5C': 'Motorola',
                '000FB3': 'Motorola',
                '000FCF': 'Motorola',
                '001620': 'Motorola',
                '001A1B': 'Motorola',
                '00215D': 'Motorola',
                '002197': 'Motorola',
                '0C3021': 'Motorola',
                '18F46A': 'Motorola',
                '00E04C': 'Realtek',
                '000BDB': 'Dell',
                '00B0D0': 'Dell',
                '001C23': 'Dell',
                '00072F': 'Cisco',
                '000A8A': 'Cisco',
                '000142': 'Cisco',
                '001279': 'Cisco'
            };

            return ouiMap[oui] || null;
        }

        // Convert decimal degrees to DMS (Degrees Minutes Seconds)
        function decimalToDMS(decimal, isLat) {
            const absolute = Math.abs(decimal);
            const degrees = Math.floor(absolute);
            const minutesFloat = (absolute - degrees) * 60;
            const minutes = Math.floor(minutesFloat);
            const seconds = ((minutesFloat - minutes) * 60).toFixed(2);

            const direction = isLat
                ? (decimal >= 0 ? 'N' : 'S')
                : (decimal >= 0 ? 'E' : 'W');

            return `${degrees}¬∞ ${minutes}' ${seconds}" ${direction}`;
        }

        // Highlight active nav
        function highlightActiveNav() {
            const currentPath = window.location.pathname;
            document.querySelectorAll('a.nav-link').forEach(link => {
                link.classList.remove('active');
                const href = link.getAttribute('href');

                if ((currentPath === '/' || currentPath === '/index.html') && (href === '/' || href === '/index.html')) {
                    link.classList.add('active');
                } else if (href !== '/' && currentPath.includes(href.replace('/', ''))) {
                    link.classList.add('active');
                }
            });
        }

        // Initialize map
        function initMap() {
            if (map) return;

            // Load Mapbox token from API
            fetch('/api/mapbox-token')
                .then(response => response.json())
                .then(data => {
                    if (data.token && data.token !== 'your-mapbox-token-here') {
                        mapboxgl.accessToken = data.token;

                        // Load saved map style from localStorage, default to standard
                        const savedStyle = localStorage.getItem('shadowcheck_map_style') || 'mapbox://styles/mapbox/standard';

                        // Set the dropdown to match saved style
                        const styleSelector = document.getElementById('map-style-selector');
                        if (styleSelector) {
                            styleSelector.value = savedStyle;
                        }

                        // Initialize map with caching
                        map = new mapboxgl.Map({
                            container: 'map',
                            style: savedStyle,
                            center: [-83.6968, 43.0234],
                            zoom: 13,
                            // Enable tile caching
                            transformRequest: (url, resourceType) => {
                                if (resourceType === 'Tile' && url.startsWith('http')) {
                                    return {
                                        url: url,
                                        headers: {},
                                        credentials: 'same-origin'
                                    };
                                }
                            }
                        });

                        // Enable browser cache for tiles
                        if ('serviceWorker' in navigator && 'caches' in window) {
                            caches.open('mapbox-tiles-v1').then(cache => {
                                console.log('‚úì Tile cache enabled');
                            });
                        }

                        map.on('load', () => {
                            console.log('‚úì Map loaded successfully');
                            loadHomeMarker();
                            // Don't load all networks automatically - only when user selects one
                            // loadNetworksToMap();

                            // Check if we need to snap to selected networks from networks page
                            const storedBounds = sessionStorage.getItem('mapBounds');
                            if (storedBounds) {
                                try {
                                    const bounds = JSON.parse(storedBounds);
                                    map.fitBounds([
                                        [bounds.minLng, bounds.minLat],
                                        [bounds.maxLng, bounds.maxLat]
                                    ], {
                                        padding: 50,
                                        maxZoom: 16
                                    });
                                    console.log('üìç Snapped to selected network bounds');
                                    // Clear the stored bounds so it doesn't happen again on refresh
                                    sessionStorage.removeItem('mapBounds');
                                } catch (e) {
                                    console.error('Failed to parse stored bounds:', e);
                                }
                            }

                            // Check for selected networks from URL parameter
                            const urlParams = new URLSearchParams(window.location.search);
                            const selectedParam = urlParams.get('selected');
                            if (selectedParam) {
                                const selectedBssids = selectedParam.split(',');
                                console.log(`üéØ Loading ${selectedBssids.length} selected networks to map`);
                                loadSelectedNetworksToMap(selectedBssids);
                            }
                        });

                        map.on('error', (e) => {
                            console.error('Map error:', e);
                        });

                        map.addControl(new mapboxgl.NavigationControl(), 'top-right');
                    } else {
                        console.error('Mapbox token not configured');
                        document.getElementById('map').innerHTML = '<div style="padding: 20px; text-align: center; color: #ef4444;">Mapbox token not configured. Please set in Admin settings.</div>';
                    }
                })
                .catch(error => {
                    console.error('Failed to load Mapbox token:', error);
                    document.getElementById('map').innerHTML = '<div style="padding: 20px; text-align: center; color: #ef4444;">Failed to load map. Check console for errors.</div>';
                });
        }

        // Load networks and add to map
        async function loadNetworks() {
            try {
                // Get all networks without limit - use filters instead
                const res = await fetch(`${API_BASE}/networks?page=1&limit=10000`);
                const data = await res.json();
                
                if (!data.networks || data.networks.length === 0) {
                    console.warn('No networks to display');
                    return;
                }

                console.log(`Loading ${data.networks.length} networks to map...`);

                // Add network points to map
                const features = data.networks
                    .filter(n => n.latitude && n.longitude)
                    .map(n => ({
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [n.longitude, n.latitude]
                        },
                        properties: {
                            bssid: n.bssid,
                            ssid: n.ssid || '<Hidden>',
                            signal: n.signal || 0,
                            type: n.type || 'W'
                        }
                    }));

                console.log(`Filtered to ${features.length} networks with coordinates`);

                map.addSource('networks', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    }
                });

                map.addLayer({
                    id: 'networks-layer',
                    type: 'circle',
                    source: 'networks',
                    paint: {
                        'circle-radius': 6,
                        'circle-color': '#3b82f6',
                        'circle-opacity': 0.7,
                        'circle-stroke-width': 1,
                        'circle-stroke-color': '#ffffff'
                    }
                });

                // Add click handler
                map.on('click', 'networks-layer', (e) => {
                    const props = e.features[0].properties;
                    const coords = e.lngLat;
                    
                    // Format timestamp
                    const timestamp = props.lasttime ? new Date(props.lasttime * 1000).toLocaleString() : 'Unknown';
                    
                    // Get manufacturer if available
                    const manufacturer = props.manufacturer || null;
                    
                    // Generate detailed tooltip
                    const tooltipHTML = generateNetworkTooltip(props, coords, manufacturer, timestamp);
                    
                    new mapboxgl.Popup({
                        className: 'dark-tooltip-popup',
                        closeButton: true,
                        closeOnClick: true,
                        maxWidth: '320px'
                    })
                        .setLngLat(coords)
                        .setHTML(tooltipHTML)
                        .addTo(map);
                });

                map.on('mouseenter', 'networks-layer', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });

                map.on('mouseleave', 'networks-layer', () => {
                    map.getCanvas().style.cursor = '';
                });

                console.log(`‚úì Loaded ${features.length} networks to map`);
            } catch (error) {
                console.error('Failed to load networks:', error);
            }
        }

        // Load observations for a specific BSSID and render with sequence numbers
        async function loadObservationsToMap(bssid, ssid) {
            if (!map) return;

            try {
                console.log(`üìç Loading observations for ${bssid}...`);
                const res = await fetch(`${API_BASE}/networks/observations/${bssid}`);

                if (!res.ok) {
                    console.error('‚úó Observations API failed:', res.status);
                    return;
                }

                const data = await res.json();

                if (!data.ok || !data.observations || data.observations.length === 0) {
                    console.warn('‚ö†Ô∏è No observations found for this BSSID');
                    return;
                }

                const observations = data.observations;
                const totalObservations = observations.length;

                console.log(`‚úì Found ${totalObservations} observations`);

                // Sort by timestamp to get temporal sequence
                observations.sort((a, b) => parseInt(a.time) - parseInt(b.time));

                // Create GeoJSON features with observation index
                const features = observations.map((obs, index) => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [obs.lon, obs.lat]
                    },
                    properties: {
                        bssid: obs.bssid,
                        ssid: obs.ssid || ssid || 'Hidden',
                        type: obs.type || 'W',
                        typeDisplay: getNetworkTypeName(obs.type || 'W'),
                        signal: obs.signal,
                        security: parseSecurityType(obs.capabilities, obs.encryption),
                        capabilities: obs.capabilities || '',
                        encryption: obs.encryption || '',
                        status: 'threat',
                        lastSeen: obs.time,
                        distanceFromHome: obs.distance_from_home_km,
                        altitude: obs.alt,
                        accuracy: obs.acc,
                        observationIndex: index + 1,
                        totalObservations: totalObservations
                    }
                }));

                // Remove existing layers and sources
                const layersToRemove = ['clusters', 'cluster-count', 'unclustered-point', 'network-labels', 'network-points', 'threat-path'];
                layersToRemove.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.removeLayer(layerId);
                    }
                });
                
                if (map.getSource('networks')) {
                    map.removeSource('networks');
                }
                if (map.getSource('threat-path')) {
                    map.removeSource('threat-path');
                }

                // Create temporal path line from observations
                const pathCoordinates = observations.map(obs => [obs.lon, obs.lat]);
                map.addSource('threat-path', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: pathCoordinates
                        }
                    }
                });

                // Add line connecting observations (movement path)
                map.addLayer({
                    id: 'threat-path',
                    type: 'line',
                    source: 'threat-path',
                    layout: {
                        'line-join': 'round',
                        'line-cap': 'round'
                    },
                    paint: {
                        'line-color': '#ef4444',
                        'line-width': 2,
                        'line-opacity': 0.6
                    }
                });

                // Add observation points source
                map.addSource('networks', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    }
                });

                // Add circle layer
                map.addLayer({
                    id: 'network-points',
                    type: 'circle',
                    source: 'networks',
                    paint: {
                        'circle-radius': 12,
                        'circle-color': '#ef4444', // Red for threats
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.9
                    }
                });

                // Add numbered labels on markers
                map.addLayer({
                    id: 'network-labels',
                    type: 'symbol',
                    source: 'networks',
                    layout: {
                        'text-field': ['get', 'observationIndex'],
                        'text-font': ['DIN Pro Bold', 'Arial Unicode MS Bold'],
                        'text-size': 11,
                        'text-allow-overlap': true,
                        'text-ignore-placement': true
                    },
                    paint: {
                        'text-color': '#ffffff',
                        'text-halo-color': '#000000',
                        'text-halo-width': 1
                    }
                });

                // Add popup on click
                map.on('click', 'network-points', async (e) => {
                    const props = e.features[0].properties;
                    const coords = e.lngLat;

                    // Format timestamp
                    const timestamp = props.lastSeen ? new Date(parseInt(props.lastSeen)).toLocaleString() : 'Unknown';

                    // Manufacturer lookup
                    const manufacturer = props.bssid ? await getManufacturerFromBSSID(props.bssid) : null;

                    // Convert coordinates to DMS
                    const latDMS = decimalToDMS(coords.lat, true);
                    const lngDMS = decimalToDMS(coords.lng, false);

                    // Altitude field
                    let altitudeField = '';
                    if (props.altitude !== undefined && props.altitude !== null && props.altitude !== 'null') {
                        altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
                    }

                    // Accuracy field
                    let accuracyField = '';
                    if (props.accuracy !== undefined && props.accuracy !== null && props.accuracy !== 'null') {
                        accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
                    }

                    // Distance from home
                    let distanceFromHome = '';
                    if (props.distanceFromHome) {
                        distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
                    }

                    // Observation count (temporal sequence)
                    let observationInfo = '';
                    if (props.observationIndex && props.totalObservations) {
                        observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
                    }

                    // Network type icon
                    const iconSvg = getNetworkIcon(props.type);

                    // Signal strength with color class
                    const signal = props.signal || 'N/A';
                    let signalClass = '';
                    if (signal !== 'N/A') {
                        if (signal >= -50) signalClass = 'signal-strong';
                        else if (signal >= -70) signalClass = 'signal-medium';
                        else signalClass = 'signal-weak';
                    }

                    const popup = new mapboxgl.Popup({
                        className: 'dark-tooltip-popup',
                        closeButton: true,
                        closeOnClick: true,
                        maxWidth: '320px'
                    })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="dark-tooltip" style="cursor: pointer;">
                                ${observationInfo}
                                <div class="tooltip-header">
                                    <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                                    ${iconSvg}
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">BSSID:</span>
                                    <span class="tooltip-value mono">${props.bssid}</span>
                                </div>
                                ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Coordinates:</span>
                                    <span class="tooltip-value mono">${latDMS}<br>${lngDMS}</span>
                                </div>
                                ${altitudeField}
                                ${accuracyField}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Type:</span>
                                    <span class="tooltip-value">${props.typeDisplay || getNetworkTypeName(props.type)}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Security:</span>
                                    <span class="tooltip-value">${props.security}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Signal:</span>
                                    <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                                </div>
                                ${distanceFromHome}
                                <div class="tooltip-timestamp">
                                    <span class="tooltip-label">Observed at:</span>
                                    <span class="tooltip-value">${timestamp}</span>
                                </div>
                            </div>
                        `)
                        .addTo(map);

                    // Add click-to-close functionality
                    setTimeout(() => {
                        const tooltipEl = popup.getElement();
                        if (tooltipEl) {
                            const contentEl = tooltipEl.querySelector('.dark-tooltip');
                            if (contentEl) {
                                contentEl.addEventListener('click', () => popup.remove());
                            }
                        }
                    }, 0);
                });

                map.on('mouseenter', 'network-points', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });

                map.on('mouseleave', 'network-points', () => {
                    map.getCanvas().style.cursor = '';
                });

                // Fit map to show all observations
                const coords = observations.map(obs => [obs.lon, obs.lat]);
                const bounds = coords.reduce((bounds, coord) => {
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coords[0], coords[0]));

                map.fitBounds(bounds, { padding: 50 });

                console.log(`‚úì Rendered ${features.length} observations with sequence numbers and tooltips`);
            } catch (err) {
                console.error('‚úó Error loading observations to map:', err);
            }
        }

        // Load networks and add to map
        async function loadNetworksToMap() {
            if (!map) return;

            try {
                console.log('üìç Loading networks to map...');
                const res = await fetch(`${API_BASE}/networks?page=1&limit=5000&sort=lastSeen&order=DESC`);

                if (!res.ok) {
                    console.error('‚úó API request failed:', res.status);
                    return;
                }

                const data = await res.json();
                const networks = data.networks || [];

                // Fetch tagged networks to apply visual styling
                const [threatsRes, safeRes] = await Promise.all([
                    fetch(`${API_BASE}/networks/tagged?tag_type=THREAT`).catch(err => {
                        console.warn('Failed to fetch threats:', err);
                        return { ok: false };
                    }),
                    fetch(`${API_BASE}/networks/tagged?tag_type=FALSE_POSITIVE`).catch(err => {
                        console.warn('Failed to fetch safe networks:', err);
                        return { ok: false };
                    })
                ]);

                const threatsData = threatsRes.ok ? await threatsRes.json() : { ok: false, networks: [] };
                const safeData = safeRes.ok ? await safeRes.json() : { ok: false, networks: [] };

                const threatBssids = new Set((threatsData.networks || []).map(n => n.bssid));
                const safeBssids = new Set((safeData.networks || []).map(n => n.bssid));

                console.log(`üè∑Ô∏è Found ${threatBssids.size} confirmed threats, ${safeBssids.size} safe networks`);

                if (!Array.isArray(networks) || networks.length === 0) {
                    console.warn('‚ö†Ô∏è No networks returned from API');
                    return;
                }

                // Filter networks with valid coordinates
                const validNetworks = networks.filter(n =>
                    n.location &&
                    n.location.lat !== null && n.location.lat !== undefined &&
                    n.location.lng !== null && n.location.lng !== undefined &&
                    !isNaN(n.location.lat) && !isNaN(n.location.lng)
                );

                console.log(`‚úì Found ${validNetworks.length} networks with valid coordinates out of ${networks.length} total`);

                // Create GeoJSON features with tag-based status
                const features = validNetworks.map(net => {
                    let status = 'normal';
                    if (threatBssids.has(net.bssid)) {
                        status = 'threat';
                    } else if (safeBssids.has(net.bssid)) {
                        status = 'safe';
                    }

                    return {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [net.location.lng, net.location.lat]
                        },
                        properties: {
                            bssid: net.bssid || 'Unknown',
                            ssid: net.ssid || 'Hidden',
                            type: net.type || 'W',
                            signal: net.signal || 'N/A',
                            security: net.security || 'Unknown',
                            status: status
                        }
                    };
                });

                // Remove old layers first (must remove layers before source)
                if (map.getLayer('network-points')) {
                    map.removeLayer('network-points');
                }
                if (map.getLayer('cluster-count')) {
                    map.removeLayer('cluster-count');
                }
                if (map.getLayer('clusters')) {
                    map.removeLayer('clusters');
                }

                // Remove and add source with clustering
                if (map.getSource('networks')) {
                    map.removeSource('networks');
                }

                map.addSource('networks', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    },
                    cluster: true,
                    clusterMaxZoom: 16, // Max zoom to cluster points on
                    clusterRadius: 50 // Radius of each cluster when clustering points
                });

                // Add cluster circles layer
                map.addLayer({
                    id: 'clusters',
                    type: 'circle',
                    source: 'networks',
                    filter: ['has', 'point_count'],
                    paint: {
                        'circle-color': [
                            'step',
                            ['get', 'point_count'],
                            '#3b82f6', 10,
                            '#f59e0b', 50,
                            '#ef4444'
                        ],
                        'circle-radius': [
                            'step',
                            ['get', 'point_count'],
                            15, 10,
                            20, 50,
                            25
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff'
                    }
                });

                // Add cluster count labels
                map.addLayer({
                    id: 'cluster-count',
                    type: 'symbol',
                    source: 'networks',
                    filter: ['has', 'point_count'],
                    layout: {
                        'text-field': '{point_count_abbreviated}',
                        'text-font': ['DIN Offc Pro Medium', 'Arial Unicode MS Bold'],
                        'text-size': 12
                    },
                    paint: {
                        'text-color': '#ffffff'
                    }
                });

                // Add unclustered points layer
                map.addLayer({
                    id: 'network-points',
                    type: 'circle',
                    source: 'networks',
                    filter: ['!', ['has', 'point_count']],
                    paint: {
                        'circle-radius': 8,
                        'circle-color': [
                            'match',
                            ['get', 'status'],
                            'threat', '#ef4444',      // Red for confirmed threats
                            'warning', '#f59e0b',     // Orange for warnings
                            'safe', '#10b981',        // Green for safe networks
                            '#3b82f6'                 // Blue for normal/untoggled networks
                        ],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': [
                            'match',
                            ['get', 'status'],
                            'threat', 1.0,            // Full opacity for threats (highlight)
                            'safe', 0.3,              // Dimmed for safe networks
                            0.7                       // Normal opacity for untoggled
                        ]
                    }
                });

                // Click handler for clusters - zoom in
                map.on('click', 'clusters', (e) => {
                    const features = map.queryRenderedFeatures(e.point, {
                        layers: ['clusters']
                    });
                    const clusterId = features[0].properties.cluster_id;
                    map.getSource('networks').getClusterExpansionZoom(
                        clusterId,
                        (err, zoom) => {
                            if (err) return;
                            map.easeTo({
                                center: features[0].geometry.coordinates,
                                zoom: zoom
                            });
                        }
                    );
                });

                // Change cursor on cluster hover
                map.on('mouseenter', 'clusters', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', 'clusters', () => {
                    map.getCanvas().style.cursor = '';
                });

                // Add popup on click for unclustered points
                map.on('click', 'network-points', async (e) => {
                    const props = e.features[0].properties;

                    // Format timestamp
                    const timestamp = props.lastSeen ? new Date(parseInt(props.lastSeen)).toLocaleString() : 'Unknown';

                    // Manufacturer lookup (simple OUI-based)
                    const manufacturer = props.bssid ? await getManufacturerFromBSSID(props.bssid) : null;

                    // Calculate distance from home if available
                    let distanceFromHome = '';
                    if (props.distanceFromHome) {
                        distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
                    }

                    // Observation count (temporal sequence)
                    let observationInfo = '';
                    if (props.observationIndex && props.totalObservations) {
                        observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
                    }

                    // Determine icon based on network type
                    const networkType = (props.type || 'wifi').toLowerCase();
                    let iconSvg = '';
                    if (networkType.includes('ble') || networkType.includes('bluetooth') || networkType === 'b' || networkType === 'e') {
                        // Bluetooth icon
                        iconSvg = `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                            <path d="M17.71 7.71L12 2h-1v7.59L6.41 5 5 6.41 10.59 12 5 17.59 6.41 19 11 14.41V22h1l5.71-5.71-4.3-4.29 4.3-4.29zM13 5.83l1.88 1.88L13 9.59V5.83zm1.88 10.46L13 18.17v-3.76l1.88 1.88z"/>
                        </svg>`;
                    } else if (networkType.includes('cellular') || networkType.includes('cell') || networkType.includes('gsm') || networkType.includes('lte') || networkType.includes('5g') || networkType === 'g' || networkType === 'l' || networkType === 'n') {
                        // Cellular/signal tower icon
                        iconSvg = `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                            <path d="M17.77 3.77L16 2 6 12l10 10 1.77-1.77L9.54 12z"/>
                            <path d="M6 12l10-10 1.77 1.77L9.54 12l8.23 8.23L16 22z"/>
                            <path d="M6 12l5-5v10z"/>
                        </svg>`;
                    } else {
                        // WiFi icon (default)
                        iconSvg = `<svg class="tooltip-icon" viewBox="0 0 24 24" fill="#22d3ee" width="16" height="16">
                            <path d="M12 18.5a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3z"/>
                            <path d="M12 14c-1.7 0-3.3.6-4.6 1.8a1 1 0 1 0 1.4 1.4A5 5 0 0 1 12 16a5 5 0 0 1 3.2 1.2 1 1 0 1 0 1.3-1.5A6.9 6.9 0 0 0 12 14z"/>
                            <path d="M12 9.5c-3 0-5.8 1.1-8 3.2a1 1 0 1 0 1.4 1.4c1.8-1.8 4.1-2.7 6.6-2.7 2.5 0 4.8.9 6.6 2.7a1 1 0 1 0 1.4-1.4c-2.2-2.1-5.1-3.2-8-3.2z"/>
                            <path d="M12 5c-4.3 0-8.3 1.6-11.3 4.6a1 1 0 1 0 1.4 1.4C4.6 7.5 8.2 6 12 6s7.4 1.5 9.9 4a1 1 0 1 0 1.4-1.4C20.3 6.6 16.3 5 12 5z"/>
                        </svg>`;
                    }

                    const popup = new mapboxgl.Popup({
                        className: 'dark-tooltip-popup',
                        closeButton: true,
                        closeOnClick: true,
                        maxWidth: '320px'
                    })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="dark-tooltip" style="cursor: pointer;">
                                ${observationInfo}
                                <div class="tooltip-header">
                                    <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                                    ${iconSvg}
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">BSSID:</span>
                                    <span class="tooltip-value mono">${props.bssid}</span>
                                </div>
                                ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Signal:</span>
                                    <span class="tooltip-value signal-${props.signal >= -50 ? 'strong' : props.signal >= -70 ? 'medium' : 'weak'}">${props.signal} dBm</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Security:</span>
                                    <span class="tooltip-value">${props.security || 'Unknown'}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Type:</span>
                                    <span class="tooltip-value">${props.type}</span>
                                </div>
                                ${distanceFromHome}
                                <div class="tooltip-timestamp">
                                    <span class="tooltip-label">Last seen:</span>
                                    <span class="tooltip-value">${timestamp}</span>
                                </div>
                            </div>
                        `)
                        .addTo(map);

                    // Add click-to-close functionality
                    setTimeout(() => {
                        const tooltipEl = popup.getElement();
                        if (tooltipEl) {
                            const contentEl = tooltipEl.querySelector('.dark-tooltip');
                            if (contentEl) {
                                contentEl.addEventListener('click', () => popup.remove());
                            }
                        }
                    }, 0);
                });

                // Create click handler for single network observations
                const singleNetworkClickHandler = async (e) => {
                    const props = e.features[0].properties;
                    const coords = e.lngLat;

                    const timestamp = props.lastSeen ? new Date(parseInt(props.lastSeen)).toLocaleString() : 'Unknown';
                    const manufacturer = props.bssid ? await getManufacturerFromBSSID(props.bssid) : null;

                    const latDMS = decimalToDMS(coords.lat, true);
                    const lngDMS = decimalToDMS(coords.lng, false);

                    let altitudeField = '';
                    if (props.altitude !== undefined && props.altitude !== null && props.altitude !== 'null') {
                        altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
                    }

                    let accuracyField = '';
                    if (props.accuracy !== undefined && props.accuracy !== null && props.accuracy !== 'null') {
                        accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
                    }

                    let distanceFromHome = '';
                    if (props.distanceFromHome) {
                        distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
                    }

                    let observationInfo = '';
                    if (props.observationIndex && props.totalObservations) {
                        observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
                    }

                    const iconSvg = getNetworkIcon(props.type);

                    const signal = props.signal || 'N/A';
                    let signalClass = '';
                    if (signal !== 'N/A') {
                        if (signal >= -50) signalClass = 'signal-strong';
                        else if (signal >= -70) signalClass = 'signal-medium';
                        else signalClass = 'signal-weak';
                    }

                    const popup = new mapboxgl.Popup({
                        className: 'dark-tooltip-popup',
                        closeButton: true,
                        closeOnClick: true,
                        maxWidth: '320px'
                    })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="dark-tooltip" style="cursor: pointer;">
                                ${observationInfo}
                                <div class="tooltip-header">
                                    <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                                    ${iconSvg}
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">BSSID:</span>
                                    <span class="tooltip-value mono">${props.bssid}</span>
                                </div>
                                ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Coordinates:</span>
                                    <span class="tooltip-value mono">${latDMS}<br>${lngDMS}</span>
                                </div>
                                ${altitudeField}
                                ${accuracyField}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Type:</span>
                                    <span class="tooltip-value">${props.typeDisplay || getNetworkTypeName(props.type)}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Security:</span>
                                    <span class="tooltip-value">${props.security}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Signal:</span>
                                    <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                                </div>
                                ${distanceFromHome}
                                <div class="tooltip-timestamp">
                                    <span class="tooltip-label">Observed at:</span>
                                    <span class="tooltip-value">${timestamp}</span>
                                </div>
                            </div>
                        `)
                        .addTo(map);

                    setTimeout(() => {
                        const tooltipEl = popup.getElement();
                        if (tooltipEl) {
                            const contentEl = tooltipEl.querySelector('.dark-tooltip');
                            if (contentEl) {
                                contentEl.addEventListener('click', () => popup.remove());
                            }
                        }
                    }, 0);
                };

                map.on('click', 'network-points', singleNetworkClickHandler);

                map.on('mouseenter', 'network-points', () => {
                    map.getCanvas().style.cursor = 'pointer';
                });

                map.on('mouseleave', 'network-points', () => {
                    map.getCanvas().style.cursor = '';
                });

                // Store data for style changes
                const pathCoordinates = observations.map(obs => [obs.lon, obs.lat]);
                currentObservationsData = {
                    features: features,
                    pathFeatures: [{
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: pathCoordinates
                        },
                        properties: {
                            bssid: bssid,
                            color: '#ef4444'
                        }
                    }],
                    clickHandler: singleNetworkClickHandler
                };

                console.log(`‚úì Added ${features.length} network markers to map`);
            } catch (err) {
                console.error('Error loading networks to map:', err);
            }
        }

        // Load observations for selected networks to map
        async function loadSelectedNetworksToMap(selectedBssids) {
            if (!map || !selectedBssids || selectedBssids.length === 0) return;

            try {
                console.log(`üìç Loading observations for ${selectedBssids.length} selected networks...`);

                // Fetch observations for all selected BSSIDs in parallel
                const observationPromises = selectedBssids.map(bssid =>
                    fetch(`${API_BASE}/networks/observations/${bssid}`)
                        .then(res => res.ok ? res.json() : null)
                        .catch(() => null)
                );

                const results = await Promise.all(observationPromises);

                // Combine all observations from all networks
                let allObservations = [];
                let networkColors = {};
                const colors = ['#ef4444', '#3b82f6', '#10b981', '#f59e0b', '#8b5cf6', '#ec4899', '#14b8a6', '#f97316'];

                results.forEach((data, index) => {
                    if (data && data.ok && data.observations && data.observations.length > 0) {
                        const bssid = selectedBssids[index];
                        networkColors[bssid] = colors[index % colors.length];
                        allObservations = allObservations.concat(
                            data.observations.map(obs => ({
                                ...obs,
                                networkColor: networkColors[bssid]
                            }))
                        );
                    }
                });

                console.log(`‚úì Found ${allObservations.length} total observations across ${selectedBssids.length} networks`);

                if (allObservations.length === 0) {
                    console.warn('‚ö†Ô∏è No observations found for selected networks');
                    return;
                }

                // Sort by timestamp
                allObservations.sort((a, b) => parseInt(a.time) - parseInt(b.time));

                // Create GeoJSON features for all observations
                const features = allObservations.map((obs, index) => ({
                    type: 'Feature',
                    geometry: {
                        type: 'Point',
                        coordinates: [obs.lon, obs.lat]
                    },
                    properties: {
                        bssid: obs.bssid,
                        ssid: obs.ssid || 'Hidden',
                        type: obs.type || 'W',
                        typeDisplay: getNetworkTypeName(obs.type || 'W'),
                        signal: obs.signal,
                        security: parseSecurityType(obs.capabilities, obs.encryption),
                        capabilities: obs.capabilities || '',
                        encryption: obs.encryption || '',
                        status: 'threat',
                        lastSeen: obs.time,
                        distanceFromHome: obs.distance_from_home_km,
                        altitude: obs.alt,
                        accuracy: obs.acc,
                        networkColor: obs.networkColor,
                        observationIndex: index + 1,
                        totalObservations: allObservations.length
                    }
                }));

                // Remove existing layers and sources
                const layersToRemove = ['clusters', 'cluster-count', 'unclustered-point', 'network-labels', 'network-points', 'threat-path', 'threat-paths'];
                layersToRemove.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.removeLayer(layerId);
                    }
                });

                if (map.getSource('networks')) map.removeSource('networks');
                if (map.getSource('threat-path')) map.removeSource('threat-path');
                if (map.getSource('threat-paths')) map.removeSource('threat-paths');

                // Create path lines for each network
                const pathFeatures = selectedBssids.map(bssid => {
                    const networkObs = allObservations.filter(obs => obs.bssid === bssid);
                    if (networkObs.length < 2) return null;

                    return {
                        type: 'Feature',
                        geometry: {
                            type: 'LineString',
                            coordinates: networkObs.map(obs => [obs.lon, obs.lat])
                        },
                        properties: {
                            bssid: bssid,
                            color: networkColors[bssid]
                        }
                    };
                }).filter(f => f !== null);

                // Add paths source
                if (pathFeatures.length > 0) {
                    map.addSource('threat-paths', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: pathFeatures
                        }
                    });

                    // Add path lines layer
                    map.addLayer({
                        id: 'threat-paths',
                        type: 'line',
                        source: 'threat-paths',
                        layout: {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        paint: {
                            'line-color': ['get', 'color'],
                            'line-width': 2,
                            'line-opacity': 0.6
                        }
                    });
                }

                // Add observation points source (no clustering for observations)
                map.addSource('networks', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: features
                    }
                });

                // Add observation points layer
                map.addLayer({
                    id: 'network-points',
                    type: 'circle',
                    source: 'networks',
                    paint: {
                        'circle-radius': 12,
                        'circle-color': ['get', 'networkColor'],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.9
                    }
                });

                // Add numbered labels on markers
                map.addLayer({
                    id: 'network-labels',
                    type: 'symbol',
                    source: 'networks',
                    layout: {
                        'text-field': ['get', 'observationIndex'],
                        'text-font': ['DIN Pro Bold', 'Arial Unicode MS Bold'],
                        'text-size': 11,
                        'text-allow-overlap': true,
                        'text-ignore-placement': true
                    },
                    paint: {
                        'text-color': '#ffffff',
                        'text-halo-color': '#000000',
                        'text-halo-width': 1
                    }
                });

                // Create click handler function for reuse
                const clickHandler = async (e) => {
                    const props = e.features[0].properties;
                    const coords = e.lngLat;

                    const timestamp = props.lastSeen ? new Date(parseInt(props.lastSeen)).toLocaleString() : 'Unknown';
                    const manufacturer = props.bssid ? await getManufacturerFromBSSID(props.bssid) : null;

                    // Convert coordinates to DMS
                    const latDMS = decimalToDMS(coords.lat, true);
                    const lngDMS = decimalToDMS(coords.lng, false);

                    // Altitude field
                    let altitudeField = '';
                    if (props.altitude !== undefined && props.altitude !== null && props.altitude !== 'null') {
                        altitudeField = `<div class="tooltip-field"><span class="tooltip-label">Altitude:</span><span class="tooltip-value">${parseFloat(props.altitude).toFixed(2)} m MSL</span></div>`;
                    }

                    // Accuracy field
                    let accuracyField = '';
                    if (props.accuracy !== undefined && props.accuracy !== null && props.accuracy !== 'null') {
                        accuracyField = `<div class="tooltip-field"><span class="tooltip-label">Accuracy:</span><span class="tooltip-value">¬±${parseFloat(props.accuracy).toFixed(1)} m</span></div>`;
                    }

                    let distanceFromHome = '';
                    if (props.distanceFromHome) {
                        distanceFromHome = `<div class="tooltip-field"><span class="tooltip-label">Distance from Home:</span><span class="tooltip-value">${parseFloat(props.distanceFromHome).toFixed(2)} km</span></div>`;
                    }

                    let observationInfo = '';
                    if (props.observationIndex && props.totalObservations) {
                        observationInfo = `<div class="tooltip-field observation-header"><span class="tooltip-value">Observation #${props.observationIndex} of ${props.totalObservations}</span></div>`;
                    }

                    const iconSvg = getNetworkIcon(props.type);

                    const signal = props.signal || 'N/A';
                    let signalClass = '';
                    if (signal !== 'N/A') {
                        if (signal >= -50) signalClass = 'signal-strong';
                        else if (signal >= -70) signalClass = 'signal-medium';
                        else signalClass = 'signal-weak';
                    }

                    const popup = new mapboxgl.Popup({ className: 'dark-tooltip-popup', closeButton: true, closeOnClick: true, maxWidth: '320px' })
                        .setLngLat(e.lngLat)
                        .setHTML(`
                            <div class="dark-tooltip" style="cursor: pointer;">
                                ${observationInfo}
                                <div class="tooltip-header">
                                    <span class="tooltip-ssid">${props.ssid || '(hidden)'}</span>
                                    ${iconSvg}
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">BSSID:</span>
                                    <span class="tooltip-value mono">${props.bssid}</span>
                                </div>
                                ${manufacturer ? `<div class="tooltip-field"><span class="tooltip-label">Manufacturer:</span><span class="tooltip-value">${manufacturer}</span></div>` : ''}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Coordinates:</span>
                                    <span class="tooltip-value mono">${latDMS}<br>${lngDMS}</span>
                                </div>
                                ${altitudeField}
                                ${accuracyField}
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Type:</span>
                                    <span class="tooltip-value">${props.typeDisplay || getNetworkTypeName(props.type)}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Security:</span>
                                    <span class="tooltip-value">${props.security}</span>
                                </div>
                                <div class="tooltip-field">
                                    <span class="tooltip-label">Signal:</span>
                                    <span class="tooltip-value ${signalClass}">${signal} dBm</span>
                                </div>
                                ${distanceFromHome}
                                <div class="tooltip-timestamp">
                                    <span class="tooltip-label">Observed at:</span>
                                    <span class="tooltip-value">${timestamp}</span>
                                </div>
                            </div>
                        `)
                        .addTo(map);

                    setTimeout(() => {
                        const tooltipEl = popup.getElement();
                        if (tooltipEl) {
                            const contentEl = tooltipEl.querySelector('.dark-tooltip');
                            if (contentEl) contentEl.addEventListener('click', () => popup.remove());
                        }
                    }, 0);
                };

                // Add click handler for observation points
                map.on('click', 'network-points', clickHandler);

                map.on('mouseenter', 'network-points', () => { map.getCanvas().style.cursor = 'pointer'; });
                map.on('mouseleave', 'network-points', () => { map.getCanvas().style.cursor = ''; });

                // Store data for style changes
                currentObservationsData = {
                    features: features,
                    pathFeatures: pathFeatures,
                    clickHandler: clickHandler
                };

                // Calculate bounding box and fit map to show all observations
                if (allObservations.length > 0) {
                    const bounds = allObservations.reduce((acc, obs) => {
                        return {
                            minLng: Math.min(acc.minLng, obs.lon),
                            maxLng: Math.max(acc.maxLng, obs.lon),
                            minLat: Math.min(acc.minLat, obs.lat),
                            maxLat: Math.max(acc.maxLat, obs.lat)
                        };
                    }, {
                        minLng: allObservations[0].lon,
                        maxLng: allObservations[0].lon,
                        minLat: allObservations[0].lat,
                        maxLat: allObservations[0].lat
                    });

                    map.fitBounds([
                        [bounds.minLng, bounds.minLat],
                        [bounds.maxLng, bounds.maxLat]
                    ], {
                        padding: 50,
                        maxZoom: 16
                    });

                    console.log(`üìç Map fitted to ${allObservations.length} observations`);
                }

                console.log(`‚úì Added ${features.length} observation points to map`);
            } catch (err) {
                console.error('Error loading selected networks to map:', err);
            }
        }

        // Store current observations data to restore after style change
        let currentObservationsData = null;

        function changeMapStyle(styleUrl) {
            if (!map) return;

            const currentCenter = map.getCenter();
            const currentZoom = map.getZoom();

            // Save the style preference
            localStorage.setItem('shadowcheck_map_style', styleUrl);

            map.setStyle(styleUrl);

            map.once('style.load', () => {
                map.setCenter(currentCenter);
                map.setZoom(currentZoom);

                // Restore layers if they were enabled
                if (document.getElementById('toggle-3d-buildings')?.checked) {
                    add3DBuildings();
                }
                if (document.getElementById('toggle-terrain')?.checked) {
                    addTerrain();
                }

                // Reload markers
                loadHomeMarker();

                // Restore network observations if they were loaded
                if (currentObservationsData) {
                    restoreObservations(currentObservationsData);
                }

                console.log('‚úì Map style changed to:', styleUrl);
            });
        }

        function restoreObservations(data) {
            if (!map || !data) return;

            try {
                // Remove existing layers and sources
                const layersToRemove = ['clusters', 'cluster-count', 'unclustered-point', 'network-labels', 'network-points', 'threat-path', 'threat-paths'];
                layersToRemove.forEach(layerId => {
                    if (map.getLayer(layerId)) {
                        map.removeLayer(layerId);
                    }
                });

                if (map.getSource('networks')) map.removeSource('networks');
                if (map.getSource('threat-path')) map.removeSource('threat-path');
                if (map.getSource('threat-paths')) map.removeSource('threat-paths');

                // Add paths source
                if (data.pathFeatures && data.pathFeatures.length > 0) {
                    map.addSource('threat-paths', {
                        type: 'geojson',
                        data: {
                            type: 'FeatureCollection',
                            features: data.pathFeatures
                        }
                    });

                    map.addLayer({
                        id: 'threat-paths',
                        type: 'line',
                        source: 'threat-paths',
                        layout: {
                            'line-join': 'round',
                            'line-cap': 'round'
                        },
                        paint: {
                            'line-color': ['get', 'color'],
                            'line-width': 2,
                            'line-opacity': 0.6
                        }
                    });
                }

                // Add observation points source
                map.addSource('networks', {
                    type: 'geojson',
                    data: {
                        type: 'FeatureCollection',
                        features: data.features
                    }
                });

                // Add observation points layer
                map.addLayer({
                    id: 'network-points',
                    type: 'circle',
                    source: 'networks',
                    paint: {
                        'circle-radius': 12,
                        'circle-color': ['get', 'networkColor'],
                        'circle-stroke-width': 2,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.9
                    }
                });

                // Add numbered labels
                map.addLayer({
                    id: 'network-labels',
                    type: 'symbol',
                    source: 'networks',
                    layout: {
                        'text-field': ['get', 'observationIndex'],
                        'text-font': ['DIN Pro Bold', 'Arial Unicode MS Bold'],
                        'text-size': 11,
                        'text-allow-overlap': true,
                        'text-ignore-placement': true
                    },
                    paint: {
                        'text-color': '#ffffff',
                        'text-halo-color': '#000000',
                        'text-halo-width': 1
                    }
                });

                // Re-add click handlers
                map.on('click', 'network-points', data.clickHandler);
                map.on('mouseenter', 'network-points', () => { map.getCanvas().style.cursor = 'pointer'; });
                map.on('mouseleave', 'network-points', () => { map.getCanvas().style.cursor = ''; });

                console.log('‚úì Restored observations on new map style');
            } catch (err) {
                console.error('Error restoring observations:', err);
            }
        }

        function toggle3DBuildings(enabled) {
            if (!map) return;
            
            if (enabled) {
                add3DBuildings();
            } else {
                if (map.getLayer('3d-buildings')) {
                    map.removeLayer('3d-buildings');
                }
            }
        }

        function add3DBuildings() {
            if (!map.getLayer('3d-buildings')) {
                const layers = map.getStyle().layers;
                const labelLayerId = layers.find(
                    (layer) => layer.type === 'symbol' && layer.layout['text-field']
                )?.id;

                map.addLayer({
                    'id': '3d-buildings',
                    'source': 'composite',
                    'source-layer': 'building',
                    'filter': ['==', 'extrude', 'true'],
                    'type': 'fill-extrusion',
                    'minzoom': 15,
                    'paint': {
                        'fill-extrusion-color': '#aaa',
                        'fill-extrusion-height': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            15,
                            0,
                            15.05,
                            ['get', 'height']
                        ],
                        'fill-extrusion-base': [
                            'interpolate',
                            ['linear'],
                            ['zoom'],
                            15,
                            0,
                            15.05,
                            ['get', 'min_height']
                        ],
                        'fill-extrusion-opacity': 0.6
                    }
                }, labelLayerId);
                
                console.log('‚úì 3D buildings enabled');
            }
        }

        function toggleTerrain(enabled) {
            if (!map) return;
            
            if (enabled) {
                addTerrain();
            } else {
                map.setTerrain(null);
                if (map.getSource('mapbox-dem')) {
                    map.removeSource('mapbox-dem');
                }
                console.log('‚úì Terrain disabled');
            }
        }

        function addTerrain() {
            if (!map.getSource('mapbox-dem')) {
                map.addSource('mapbox-dem', {
                    'type': 'raster-dem',
                    'url': 'mapbox://mapbox.mapbox-terrain-dem-v1',
                    'tileSize': 512,
                    'maxzoom': 14
                });
            }
            
            map.setTerrain({ 'source': 'mapbox-dem', 'exaggeration': 1.5 });
            console.log('‚úì Terrain enabled');
        }

        function centerMapOnLocation() {
            if (map) {
                map.flyTo({ center: [-83.69, 43.02], zoom: 12 });
            }
        }

        // Center on saved home location
        async function centerOnHome() {
            if (!map) return;
            
            try {
                const response = await fetch(`${API_BASE}/location-markers/home`);
                if (response.ok) {
                    const data = await response.json();
                    if (data.marker) {
                        map.flyTo({
                            center: [data.marker.longitude, data.marker.latitude],
                            zoom: 16
                        });
                        console.log('‚úì Centered on home location');
                    } else {
                        alert('No home location set. Please set your home location in settings.');
                    }
                } else {
                    alert('No home location found');
                }
            } catch (error) {
                console.error('Error fetching home location:', error);
                alert('Failed to load home location');
            }
        }

        // Center on current GPS location
        function centerOnCurrentLocation() {
            if (!map) return;
            
            if ('geolocation' in navigator) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        map.flyTo({
                            center: [position.coords.longitude, position.coords.latitude],
                            zoom: 16
                        });
                        console.log('‚úì Centered on current GPS location');
                    },
                    (error) => {
                        console.error('Geolocation error:', error);
                        alert('Unable to get your location. Please enable location services.');
                    },
                    { enableHighAccuracy: true, timeout: 10000 }
                );
            } else {
                alert('Geolocation is not supported by your browser');
            }
        }

        // Fit all networks in view
        function fitBounds() {
            if (!map) return;
            
            // Get all network markers
            const source = map.getSource('network-points');
            if (source && source._data && source._data.features && source._data.features.length > 0) {
                const bounds = new mapboxgl.LngLatBounds();
                
                source._data.features.forEach(feature => {
                    bounds.extend(feature.geometry.coordinates);
                });
                
                map.fitBounds(bounds, { padding: 50, maxZoom: 15 });
                console.log('‚úì Fitted bounds to all networks');
            } else {
                alert('No networks loaded on map');
            }
        }

        // Set home location at map center
        async function setHomeLocation() {
            if (!map) return;
            
            const center = map.getCenter();
            const btn = document.getElementById('set-home-btn');
            
            try {
                btn.textContent = '‚è≥ Setting...';
                btn.disabled = true;
                
                const response = await fetch(`${API_BASE}/location-markers/home`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        latitude: center.lat,
                        longitude: center.lng
                    })
                });
                
                if (!response.ok) {
                    throw new Error('Failed to set home location');
                }
                
                const data = await response.json();
                console.log('‚úì Home location set:', data.marker);
                
                // Add home marker to map
                if (map.getLayer('home-marker')) {
                    map.removeLayer('home-marker');
                    map.removeSource('home-marker');
                }
                
                map.addSource('home-marker', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [center.lng, center.lat]
                        }
                    }
                });
                
                map.addLayer({
                    id: 'home-marker',
                    type: 'circle',
                    source: 'home-marker',
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#10b981',
                        'circle-stroke-width': 3,
                        'circle-stroke-color': '#ffffff'
                    }
                });
                
                btn.textContent = '‚úì Home Set';
                setTimeout(() => {
                    btn.textContent = 'üè† Set Home';
                    btn.disabled = false;
                }, 2000);
                
                // Reload threats to recalculate distances
                loadThreats();
            } catch (err) {
                console.error('Error setting home location:', err);
                btn.textContent = '‚úó Failed';
                setTimeout(() => {
                    btn.textContent = 'üè† Set Home';
                    btn.disabled = false;
                }, 2000);
            }
        }

        // Load home marker on map init
        async function loadHomeMarker() {
            if (!map) return;
            
            try {
                const response = await fetch(`${API_BASE}/location-markers`);
                const data = await response.json();
                
                const homeMarker = data.markers?.find(m => m.marker_type === 'home');
                if (!homeMarker) return;
                
                if (map.getLayer('home-marker')) {
                    map.removeLayer('home-marker');
                    map.removeSource('home-marker');
                }
                
                map.addSource('home-marker', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [homeMarker.longitude, homeMarker.latitude]
                        }
                    }
                });
                
                map.addLayer({
                    id: 'home-marker',
                    type: 'circle',
                    source: 'home-marker',
                    paint: {
                        'circle-radius': 10,
                        'circle-color': '#10b981',
                        'circle-stroke-width': 3,
                        'circle-stroke-color': '#ffffff'
                    }
                });
                
                console.log('‚úì Home marker loaded');
            } catch (err) {
                console.log('No home marker set');
            }
        }

        // Draw circle around home location
        async function updateHomeCircle(radiusMeters) {
            if (!map) return;
            
            const radius = parseFloat(radiusMeters);
            
            // Remove existing circle
            if (map.getLayer('home-circle')) {
                map.removeLayer('home-circle');
                map.removeSource('home-circle');
            }
            
            if (radius <= 0) return;
            
            try {
                const response = await fetch(`${API_BASE}/location-markers/home`);
                const data = await response.json();
                if (!data.marker) return;
                
                const center = [data.marker.longitude, data.marker.latitude];
                const points = 64;
                const coords = [];
                
                for (let i = 0; i <= points; i++) {
                    const angle = (i / points) * 2 * Math.PI;
                    const dx = radius * Math.cos(angle);
                    const dy = radius * Math.sin(angle);
                    
                    // Convert meters to degrees (approximate)
                    const lat = center[1] + (dy / 111320);
                    const lng = center[0] + (dx / (111320 * Math.cos(center[1] * Math.PI / 180)));
                    coords.push([lng, lat]);
                }
                
                map.addSource('home-circle', {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Polygon',
                            coordinates: [coords]
                        }
                    }
                });
                
                map.addLayer({
                    id: 'home-circle',
                    type: 'line',
                    source: 'home-circle',
                    paint: {
                        'line-color': '#10b981',
                        'line-width': 2,
                        'line-opacity': 0.8
                    }
                });
            } catch (err) {
                console.error('Failed to draw home circle:', err);
            }
        }

        // Get severity class based on threat score
        function getSeverityClass(score) {
            if (score >= 80) return 'severity-critical';
            if (score >= 70) return 'severity-high';
            if (score >= 50) return 'severity-medium';
            return 'severity-low';
        }

        // Get severity label based on threat score
        function getSeverityLabel(score) {
            if (score >= 80) return 'Critical';
            if (score >= 70) return 'High';
            if (score >= 50) return 'Medium';
            return 'Low';
        }

        // Tag a network as safe or threat
        async function tagNetwork(bssid, tagType, confidence = 50) {
            try {
                const API_KEY = localStorage.getItem('shadowcheck_api_key') || 'your-secure-random-key-here';
                
                const response = await fetch(`${API_BASE}/tag-network`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'X-API-Key': API_KEY
                    },
                    body: JSON.stringify({
                        bssid: bssid,
                        tag_type: tagType,
                        confidence: confidence,
                        notes: `User tagged as ${tagType}`
                    })
                });

                if (!response.ok) {
                    console.error('‚úó Tag network failed:', response.status);
                    return false;
                }

                const result = await response.json();
                console.log(`‚úì Network tagged: ${bssid} as ${tagType}`);

                // Reload the threat list to reflect changes
                await loadThreats(false);
                return true;
            } catch (err) {
                console.error('‚úó Error tagging network:', err);
                return false;
            }
        }

        // Threats infinite scroll state
        let threatPage = 1;
        let allThreatsLoaded = false;
        let minThreatSeverity = 'all'; // Default: show all
        let selectedThreatType = ''; // Default: show all types

        async function loadThreats(append = false) {
            try {
                // Always fetch all threats, then filter client-side
                const url = `${API_BASE}/threats/quick?page=${threatPage}&limit=200`;

                const res = await fetch(url);
                const data = await res.json();

                const threatList = document.getElementById('threat-list');
                const threatsCount = document.getElementById('threats-count');

                if (!append) {
                    threatList.innerHTML = '';
                    threatPage = 1;
                    allThreatsLoaded = false;
                }

                if (!data.threats || data.threats.length === 0) {
                    if (!append) {
                        threatList.innerHTML = '<div class="loading">No threats detected</div>';
                        if (threatsCount) threatsCount.textContent = '0';
                    }
                    allThreatsLoaded = true;
                    return;
                }

                // Filter threats by selected severity level and type
                let filteredThreats = data.threats;
                if (minThreatSeverity !== 'all') {
                    filteredThreats = filteredThreats.filter(threat => {
                        const severityClass = getSeverityClass(threat.threatScore);
                        return severityClass === `severity-${minThreatSeverity}`;
                    });
                }
                
                if (selectedThreatType) {
                    filteredThreats = filteredThreats.filter(threat => threat.type === selectedThreatType);
                }

                if (filteredThreats.length === 0) {
                    if (!append) {
                        threatList.innerHTML = '<div class="loading">No threats match filters</div>';
                        if (threatsCount) threatsCount.textContent = '0';
                    }
                    allThreatsLoaded = true;
                    return;
                }

                // Update count with total from API
                if (!append && threatsCount) {
                    threatsCount.textContent = data.total || filteredThreats.length;
                }

                // Check if we got fewer threats than requested (end of list)
                if (data.threats.length < 200) {
                    allThreatsLoaded = true;
                }

                filteredThreats.forEach(threat => {
                    const row = document.createElement('div');
                    const severityClass = getSeverityClass(threat.threatScore);
                    const severityLabel = getSeverityLabel(threat.threatScore);

                    row.className = `threat-row ${severityClass}`;
                    row.innerHTML = `
                        <div style="flex: 1; min-width: 0;">
                            <div style="display: flex; align-items: center; gap: 8px; flex-wrap: wrap;">
                                <div style="font-weight: 600; font-size: 13px; color: #f1f5f9; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;">
                                    ${escapeHtml(threat.ssid) || 'Hidden Network'}
                                </div>
                                <span class="threat-score ${severityClass}">${escapeHtml(severityLabel)}: ${threat.threatScore}</span>
                            </div>
                            <div style="font-size: 11px; color: #94a3b8; margin-top: 2px;">
                                ${escapeHtml(threat.bssid)} ‚Ä¢ ${threat.totalObservations} obs ‚Ä¢ ${new Date(parseInt(threat.firstSeen)).toLocaleDateString()} - ${new Date(parseInt(threat.lastSeen)).toLocaleDateString()} (${threat.timespanDays}d)
                            </div>
                        </div>
                        <div style="display: flex; gap: 4px; flex-shrink: 0;">
                            <button class="tag-safe-btn" style="
                                background: rgba(34, 197, 94, 0.2);
                                border: 1px solid rgba(34, 197, 94, 0.4);
                                color: #4ade80;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                font-weight: 600;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Mark as safe">‚úì Safe</button>
                            <button class="tag-threat-btn" style="
                                background: rgba(239, 68, 68, 0.2);
                                border: 1px solid rgba(239, 68, 68, 0.4);
                                color: #f87171;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                font-weight: 600;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Confirm threat">‚ö† Threat</button>
                            <button class="map-btn" style="
                                background: rgba(59, 130, 246, 0.2);
                                border: 1px solid rgba(59, 130, 246, 0.4);
                                color: #60a5fa;
                                padding: 4px 8px;
                                border-radius: 4px;
                                font-size: 10px;
                                font-weight: 600;
                                cursor: pointer;
                                white-space: nowrap;
                            " title="Show on map">üìç Map</button>
                        </div>
                    `;

                    // Add event listeners for tagging buttons
                    const safeBtn = row.querySelector('.tag-safe-btn');
                    const threatBtn = row.querySelector('.tag-threat-btn');
                    const mapBtn = row.querySelector('.map-btn');

                    safeBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        safeBtn.style.animation = 'flash 0.3s ease';
                        setTimeout(() => safeBtn.style.animation = '', 300);
                        await tagNetwork(threat.bssid, 'FALSE_POSITIVE', 90);
                    });

                    threatBtn.addEventListener('click', async (e) => {
                        e.stopPropagation();
                        threatBtn.style.animation = 'flash 0.3s ease';
                        setTimeout(() => threatBtn.style.animation = '', 300);
                        await tagNetwork(threat.bssid, 'THREAT', 90);
                    });

                    mapBtn.addEventListener('click', (e) => {
                        e.stopPropagation();
                        mapBtn.style.animation = 'flash 0.3s ease';
                        setTimeout(() => mapBtn.style.animation = '', 300);
                        loadObservationsToMap(threat.bssid, threat.ssid);
                        
                        // Highlight selected threat
                        document.querySelectorAll('.threat-row').forEach(r => {
                            r.style.background = '';
                            r.style.opacity = '0.6';
                        });
                        row.style.background = 'rgba(59, 130, 246, 0.2)';
                        row.style.opacity = '1';
                    });

                    // Add click handler to load observations (same as map button)
                    row.style.cursor = 'pointer';
                    row.addEventListener('click', () => {
                        console.log(`üéØ Threat selected: ${threat.ssid || 'Hidden'} (${threat.bssid})`);
                        loadObservationsToMap(threat.bssid, threat.ssid);

                        // Highlight selected threat
                        document.querySelectorAll('.threat-row').forEach(r => {
                            r.style.background = '';
                            r.style.opacity = '0.6';
                        });
                        row.style.background = 'rgba(59, 130, 246, 0.2)';
                        row.style.opacity = '1';
                    });

                    threatList.appendChild(row);
                });

                console.log(`‚úì Loaded ${data.threats.length} threats (page ${threatPage})`);
            } catch (err) {
                console.error('Error loading threats:', err);
            }
        }

        // Initialize network table manager (abbreviated mode for geospatial)
        let networkTable = null;

        async function loadNetworks() {
            try {
                console.log('üì° Loading recent networks...');
                const res = await fetch(`${API_BASE}/networks?page=1&limit=1000&sort=lastSeen&order=DESC`);

                if (!res.ok) {
                    console.error('‚úó Networks API failed:', res.status);
                    const tbody = document.querySelector('#networks-table tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="4" class="loading">API Error: ' + res.status + '</td></tr>';
                    }
                    return;
                }

                const data = await res.json();
                let networks = data.networks || [];
                console.log(`üì° API returned ${networks?.length || 0} networks (total: ${data.totalCount || 0})`);

                if (!Array.isArray(networks) || networks.length === 0) {
                    console.warn('‚ö†Ô∏è No networks returned from API');
                    const tbody = document.querySelector('#networks-table tbody');
                    if (tbody) {
                        tbody.innerHTML = '<tr><td colspan="4" class="loading">No networks found</td></tr>';
                    }
                    return;
                }

                // Initialize table manager with full grid (same as networks page)
                if (!networkTable) {
                    console.log('üìä Initializing NetworkTableManager for geospatial...');
                    networkTable = new NetworkTableManager('geospatial', false);
                    window.networkTable = networkTable; // Make globally accessible
                }

                // Enrich network data with formatted fields
                networks = networks.map(net => {
                    const parsedSecurity = parseSecurityType(net.capabilities, net.encryption);
                    if (window.DEBUG_SECURITY) {
                        console.log('Security parse:', {
                            capabilities: net.capabilities,
                            encryption: net.encryption,
                            result: parsedSecurity
                        });
                    }
                    return {
                        ...net,
                        type: net.type || 'W',
                        typeDisplay: getNetworkTypeName(net.type),
                        security: parsedSecurity,
                        timestamp: net.lastSeen || net.time || Date.now(),
                        observations: net.observationCount || 1,
                        latitude: net.location?.lat,
                        longitude: net.location?.lng
                    };
                });

                console.log(`üìä Enriched ${networks.length} networks, setting data...`);

                // Set networks data (no artificial limits)
                networkTable.setNetworks(networks);

                console.log(`üìä Rendering table with ${networkTable.filteredNetworks.length} filtered networks...`);

                // Render table with click handler to load observations and render on map
                renderNetworkTable('networks-table', (network) => {
                    console.log(`üì° Network selected: ${network.ssid || 'Hidden'} (${network.bssid})`);
                    loadObservationsToMap(network.bssid, network.ssid);

                    // Highlight selected row
                    document.querySelectorAll('#networks-table tbody tr').forEach(r => {
                        r.style.background = '';
                    });
                    const selectedRow = document.querySelector(`#networks-table tbody tr[data-bssid="${network.bssid}"]`);
                    if (selectedRow) {
                        selectedRow.style.background = 'rgba(59, 130, 246, 0.2)';
                    }
                });

                console.log(`‚úì Displayed ${networkTable.displayedCount} of ${networkTable.filteredNetworks.length} networks in table`);
            } catch (err) {
                console.error('‚úó Error loading networks:', err);
                const tbody = document.querySelector('#networks-table tbody');
                if (tbody) {
                    tbody.innerHTML = '<tr><td colspan="4" class="loading">Error: ' + err.message + '</td></tr>';
                }
            }
        }

        // Check for URL parameters and auto-load threat observations
        function checkURLParameters() {
            const urlParams = new URLSearchParams(window.location.search);
            const bssid = urlParams.get('bssid');
            const ssid = urlParams.get('ssid');

            if (bssid) {
                console.log(`üéØ URL parameter detected - auto-loading observations for ${bssid}`);
                // Wait for map to initialize, then load observations
                const checkMapInterval = setInterval(() => {
                    if (map) {
                        clearInterval(checkMapInterval);
                        loadObservationsToMap(bssid, ssid || 'Unknown');
                    }
                }, 100);
            }
        }

        // Initialize on load
        // Setup infinite scroll for both threats and networks panels
        function setupInfiniteScroll() {
            // Threats panel infinite scroll
            const threatsPanel = document.querySelector('#threats-panel .panel-content');
            if (threatsPanel) {
                let isLoadingThreats = false;

                threatsPanel.addEventListener('scroll', () => {
                    if (isLoadingThreats || allThreatsLoaded) return;

                    const { scrollTop, scrollHeight, clientHeight } = threatsPanel;

                    // Trigger when 100px from bottom
                    if (scrollTop + clientHeight >= scrollHeight - 100) {
                        isLoadingThreats = true;
                        threatPage++;
                        console.log(`üìú Loading more threats (page ${threatPage})`);

                        loadThreats(true).then(() => {
                            isLoadingThreats = false;
                        });
                    }
                });
            }

            // Networks panel infinite scroll
            const networksPanel = document.querySelector('#networks-panel .panel-content');
            if (networksPanel) {
                let isLoadingNetworks = false;

                networksPanel.addEventListener('scroll', () => {
                    if (isLoadingNetworks || !window.networkTable) return;

                    const { scrollTop, scrollHeight, clientHeight } = networksPanel;

                    // Trigger when 100px from bottom (smaller trigger for abbreviated mode)
                    if (scrollTop + clientHeight >= scrollHeight - 100) {
                        if (networkTable.hasMore()) {
                            isLoadingNetworks = true;
                            console.log(`üìú Loading more networks (${networkTable.displayedCount}/${networkTable.getSortedNetworks().length})`);

                            networkTable.loadMore();
                            renderNetworkTable('networks-table', (network) => {
                                console.log(`üì° Network selected: ${network.ssid || 'Hidden'} (${network.bssid})`);
                                loadObservationsToMap(network.bssid, network.ssid);

                                // Highlight selected row
                                document.querySelectorAll('#networks-table tbody tr').forEach(r => {
                                    r.style.background = '';
                                });
                                const selectedRow = document.querySelector(`#networks-table tbody tr[data-bssid="${network.bssid}"]`);
                                if (selectedRow) {
                                    selectedRow.style.background = 'rgba(59, 130, 246, 0.2)';
                                }
                            }, true); // append = true

                            setTimeout(() => { isLoadingNetworks = false; }, 100);
                        }
                    }
                });
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            // Register service worker for tile caching
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('/sw-map-cache.js')
                    .then(reg => console.log('‚úì Map tile cache service worker registered'))
                    .catch(err => console.warn('Service worker registration failed:', err));
            }

            highlightActiveNav();
            setTimeout(() => initMap(), 100);
            loadThreats();
            loadNetworks();
            checkURLParameters();
            setupInfiniteScroll();
        });

        const refreshBtn = document.getElementById('refresh-btn');
        if (refreshBtn) {
            refreshBtn.addEventListener('click', () => {
                loadThreats();
                loadNetworks();
                // Don't reload map points - user selects threat
            });
        }

        // Wire up filter controls
        document.addEventListener('DOMContentLoaded', () => {
            // Network search with debounce
            const networkSearch = document.getElementById('network-search');
            let networkSearchTimeout;
            if (networkSearch && window.networkTable) {
                networkSearch.addEventListener('input', (e) => {
                    clearTimeout(networkSearchTimeout);
                    networkSearchTimeout = setTimeout(() => {
                        networkTable.applySearch(e.target.value);
                        renderNetworkTable('networks-table', (network) => {
                            loadObservationsToMap(network.bssid, network.ssid);
                        });
                    }, 300);
                });
            }

            // Network type filter
            const networkTypeFilter = document.getElementById('network-type-filter');
            if (networkTypeFilter) {
                networkTypeFilter.addEventListener('change', (e) => {
                    // Filter logic will be added in next iteration
                    console.log('Network type filter:', e.target.value);
                });
            }

            // Network security filter
            const networkSecurityFilter = document.getElementById('network-security-filter');
            if (networkSecurityFilter) {
                networkSecurityFilter.addEventListener('change', (e) => {
                    // Filter logic will be added in next iteration
                    console.log('Network security filter:', e.target.value);
                });
            }

            // Threat search
            const threatSearch = document.getElementById('threat-search');
            if (threatSearch) {
                threatSearch.addEventListener('input', (e) => {
                    const searchTerm = e.target.value.toLowerCase();
                    const threats = document.querySelectorAll('.threat-row');
                    threats.forEach(threat => {
                        const text = threat.textContent.toLowerCase();
                        threat.style.display = text.includes(searchTerm) ? '' : 'none';
                    });
                });
            }

            // Threat severity filter
            const threatSeverityFilter = document.getElementById('threat-severity-filter');
            if (threatSeverityFilter) {
                threatSeverityFilter.addEventListener('change', (e) => {
                    minThreatSeverity = e.target.value;
                    console.log(`üéöÔ∏è Threat severity filter changed to: ${minThreatSeverity}`);
                    loadThreats(false); // Reload threats with new filter
                });
            }

            // Threat type filter
            const threatTypeFilter = document.getElementById('threat-type-filter');
            if (threatTypeFilter) {
                threatTypeFilter.addEventListener('change', (e) => {
                    selectedThreatType = e.target.value;
                    console.log('üéöÔ∏è Threat type filter changed to:', selectedThreatType || 'all');
                    loadThreats();
                });
            }

            // Layout toggle functionality
            const mainGrid = document.getElementById('main-grid');
            const layoutButtons = {
                'layout-side': 'layout-side-by-side',
                'layout-vertical': 'layout-vertical',
                'layout-map': 'layout-map-focus'
            };

            // Load saved layout preference
            const savedLayout = localStorage.getItem('geospatial-layout') || 'layout-side-by-side';
            if (mainGrid) {
                mainGrid.className = `main ${savedLayout}`;
            }
            Object.keys(layoutButtons).forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn && layoutButtons[btnId] === savedLayout) {
                    btn.classList.add('active');
                }
            });

            // Add click handlers for layout buttons
            Object.keys(layoutButtons).forEach(btnId => {
                const btn = document.getElementById(btnId);
                if (btn) {
                    btn.addEventListener('click', () => {
                        const layoutClass = layoutButtons[btnId];
                        if (mainGrid) {
                            mainGrid.className = `main ${layoutClass}`;
                        }
                        localStorage.setItem('geospatial-layout', layoutClass);
                        
                        // Update active button
                        Object.keys(layoutButtons).forEach(id => {
                            const button = document.getElementById(id);
                            if (button) button.classList.remove('active');
                        });
                        if (btn) btn.classList.add('active');
                    
                        // Resize map after layout change
                        setTimeout(() => {
                            if (map) map.resize();
                        }, 350);
                    });
                }
            });

            // Network row click handler - render on map
            function handleNetworkRowClick(network) {
                if (!network.location || !network.location.lat || !network.location.lng) {
                    console.log('Network has no location data');
                    return;
                }

                // Center map on network location
                map.flyTo({
                    center: [network.location.lng, network.location.lat],
                    zoom: 16,
                    duration: 1000
                });

                // Add or update marker for this network
                const markerId = `selected-${network.bssid}`;
                
                // Remove previous selected marker
                if (map.getLayer(markerId)) {
                    map.removeLayer(markerId);
                    map.removeSource(markerId);
                }

                // Add new marker
                map.addSource(markerId, {
                    type: 'geojson',
                    data: {
                        type: 'Feature',
                        geometry: {
                            type: 'Point',
                            coordinates: [network.location.lng, network.location.lat]
                        },
                        properties: {
                            bssid: network.bssid,
                            ssid: network.ssid || 'Hidden',
                            type: network.type
                        }
                    }
                });

                map.addLayer({
                    id: markerId,
                    type: 'circle',
                    source: markerId,
                    paint: {
                        'circle-radius': 12,
                        'circle-color': '#3b82f6',
                        'circle-stroke-width': 3,
                        'circle-stroke-color': '#ffffff',
                        'circle-opacity': 0.8
                    }
                });

                // Show popup
                new mapboxgl.Popup()
                    .setLngLat([network.location.lng, network.location.lat])
                    .setHTML(`
                        <div style="color: #1e293b; font-size: 12px;">
                            <strong>${network.ssid || 'Hidden Network'}</strong><br>
                            ${network.bssid}<br>
                            Type: ${network.type} | Signal: ${network.signal || 'N/A'} dBm
                        </div>
                    `)
                    .addTo(map);
            }
        });
    </script>
    
    
    <script src="/assets/js/radio-icons.js"></script>
    <script src="/assets/js/unified-card-library.js"></script>
    <script src="/assets/js/unified-components.js"></script>
    <script src="/assets/js/base-components.js"></script>
            }
        });
</body>
</html>